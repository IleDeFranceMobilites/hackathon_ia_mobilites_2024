{"themes":"Appel à un LLM, ","id_pepite":17,"equipe":"equipe_08_maidfm - Hackathon-IDFM","langage":"PYTHON","is_api_idfm":0,"is_api_autres":0,"is_appel_llm":1,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":0,"is_geocoding":0,"is_angular":0,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_08_maidfm%20%-%20%Hackathon-IDFM/prompt_billettique.py","code":"def generate_custom_message(user_data): ... def test_llm(): ...","description":"Ce fichier utilise un modèle de langage pour générer des messages personnalisés pour les utilisateurs en fonction de leurs informations de billettique.","reutilisabilite":"La fonction de génération de messages personnalisés est réutilisable pour tout projet nécessitant une communication personnalisée basée sur des données utilisateurs.","specificites_fonctionnelles":"Le code répond au besoin de notifier les utilisateurs sur l'état de leur billettique, améliorant ainsi l'expérience utilisateur.","value_index":0.015873015873015872}
{"themes":"Appel à un LLM, ","id_pepite":42,"equipe":"equipe_08_maidfm","langage":"PYTHON","is_api_idfm":0,"is_api_autres":0,"is_appel_llm":1,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":0,"is_geocoding":0,"is_angular":0,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_08_maidfm/Hackathon-IDFM-main/Hackathon_équipe8/domain/llm/keys.py","code":"from dotenv import load_dotenv\nimport os\nload_dotenv(\".env\")\n\nAZURE_OPENAI_KEY = \"REMOVED\"\nOPENAI_ENDPOINT = \"https://dlb-team08-prd-oai01.openai.azure.com/\"\nMODEL_NAME = \"gpt-4o-mini\"","description":"Ce fichier charge les variables d'environnement nécessaires pour configurer l'accès à l'API Azure OpenAI, notamment la clé API, l'endpoint et le nom du modèle.","reutilisabilite":"Ce code est réutilisable pour toute application nécessitant une configuration d'accès à l'API Azure OpenAI. Il centralise les informations de configuration, facilitant leur gestion et leur modification.","specificites_fonctionnelles":"Fournit les configurations de base pour l'accès à un service LLM via Azure.","value_index":0.005434782608695652}
{"themes":"Appel à un LLM, ","id_pepite":43,"equipe":"equipe_08_maidfm","langage":"PYTHON","is_api_idfm":0,"is_api_autres":0,"is_appel_llm":1,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":0,"is_geocoding":0,"is_angular":0,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_08_maidfm/Hackathon-IDFM-main/old/llm/keys.py","code":"from dotenv import load_dotenv\nimport os\nload_dotenv(\".env\")\n\nAZURE_OPENAI_KEY = \"REMOVED\"\nOPENAI_ENDPOINT = \"https://dlb-team08-prd-oai01.openai.azure.com/\"\nMODEL_NAME = \"gpt-4o-mini\"","description":"Ce fichier charge les variables d'environnement nécessaires pour configurer l'accès à l'API Azure OpenAI, notamment la clé API, l'endpoint et le nom du modèle.","reutilisabilite":"Ce code est réutilisable pour toute application nécessitant une configuration d'accès à l'API Azure OpenAI. Il centralise les informations de configuration, facilitant ainsi leur gestion et leur modification.","specificites_fonctionnelles":"Ce fichier répond au besoin de sécuriser et de centraliser les informations de configuration pour l'accès à l'API Azure OpenAI.","value_index":0.005434782608695652}
{"themes":"Appel à un LLM, ","id_pepite":90,"equipe":"equipe_09_alterego","langage":"PYTHON","is_api_idfm":0,"is_api_autres":0,"is_appel_llm":1,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":0,"is_geocoding":0,"is_angular":0,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_09_alterego/idfm_hackaton_2024-main/backend/api-llm/src/client.py","code":"import os\nfrom openai import AzureOpenAI\nfrom dotenv import load_dotenv\nfrom pathlib import Path\n\n\nclass Client:\n    def __init__(self):\n        path_secrets = os.getcwd()+\"/secrets.env\"\n        load_dotenv(dotenv_path=Path(path_secrets).resolve())\n        self.openAiKey = os.getenv(\"OPENAI_API_KEY\")\n        self.end_point = os.getenv(\"OPENAI_AZURE_ENDPOINT\")\n        self.api_version = os.getenv(\"API_VERSION\")\n\n    def get_client(self):\n        client = AzureOpenAI(\n            azure_endpoint=self.end_point,\n            api_key=self.openAiKey,\n            api_version=self.api_version\n        )\n        return client","description":"Ce code initialise un client pour interagir avec l'API Azure OpenAI en chargeant les clés API et les points de terminaison à partir d'un fichier d'environnement.","reutilisabilite":"Ce code est réutilisable pour toute application nécessitant une connexion à l'API Azure OpenAI, car il centralise la gestion des clés API et des points de terminaison.","specificites_fonctionnelles":"Permet de configurer et d'initialiser un client pour interagir avec l'API Azure OpenAI.","value_index":0.001607717041800643}
{"themes":"Appel à un LLM, ","id_pepite":91,"equipe":"equipe_01_accit_falc","langage":"PYTHON","is_api_idfm":0,"is_api_autres":0,"is_appel_llm":1,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":0,"is_geocoding":0,"is_angular":0,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_01_accit_falc/app/core/models.py","code":"import importlib\nimport os\n\nfrom app.models.config import LLMConfig\n\n\ndef get_model(model_name: str, params: LLMConfig):\n    model_package, module_name = params.model_class.rsplit(\".\", 1)\n\n    module = importlib.import_module(model_package)\n    module = getattr(module, module_name)\n\n    fill_secrets_from_env(model_name, params)\n\n    return module(**params.model_dump(exclude=[\"model_class\"]))\n\n\ndef fill_secrets_from_env(model_name: str, params: LLMConfig):\n    for key, value in params.model_dump().items():\n        if value == \"SECRET\":\n            setattr(params, key, os.getenv(f\"{model_name.upper()}_{key.upper()}\"))","description":"Ce code charge dynamiquement un modèle de langage en utilisant des configurations spécifiées et remplit les secrets à partir des variables d'environnement.","reutilisabilite":"La fonction `get_model` est hautement réutilisable pour charger différents modèles de langage en fonction de configurations dynamiques, ce qui est crucial pour des applications nécessitant une flexibilité dans le choix des modèles d'IA.","specificites_fonctionnelles":"Permet de gérer dynamiquement les modèles de langage en fonction des besoins de l'application, en assurant la sécurité des secrets via les variables d'environnement.","value_index":0.0016051364365971107}
{"themes":"Appel à un LLM, Conception de prompts, Génération de données, ","id_pepite":39,"equipe":"equipe_04_mobiwize","langage":"JAVASCRIPT","is_api_idfm":0,"is_api_autres":0,"is_appel_llm":1,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":1,"is_geocoding":0,"is_angular":0,"is_data_generation":1,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_04_mobiwize/ai-framework-main/packages/ai-toolkit/src/graphs/researcher/index.ts","code":"export const generateQueries = async (state: typeof ResearcherGraphAnnotation.State): Promise<ResearcherGraphReturnType> => { const modelWithTool = llm.withStructuredOutput(z.object({ queries: z.array(z.string()).describe(\"List of generated search queries\").max(3) }), {name: \"generate_queries\"}); const messages = [ {role: \"system\", content: getDefaultPromptConfig().generateQueriesSystemPrompt}, {role: \"human\", content: state.question} ]; const response = await modelWithTool.invoke(messages); return {queries: response.queries}; };","description":"Génère des requêtes de recherche basées sur une question donnée en utilisant un modèle de langage.","reutilisabilite":"La génération de requêtes est un composant réutilisable pour tout système nécessitant des recherches basées sur des questions.","specificites_fonctionnelles":"Permet de créer des requêtes de recherche variées pour couvrir différents aspects d'une question.","value_index":0.005607476635514018}
{"themes":"Appel à un LLM, Conception de prompts, Prise en compte de la frugalité, ","id_pepite":59,"equipe":"equipe_08_maidfm","langage":"PYTHON","is_api_idfm":0,"is_api_autres":0,"is_appel_llm":1,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":1,"is_geocoding":0,"is_angular":0,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_08_maidfm/Hackathon-IDFM-main/Hackathon_équipe8/domain/llm/llm_management.py","code":"from openai import AzureOpenAI\nfrom llm.keys import OPENAI_ENDPOINT, MODEL_NAME, AZURE_OPENAI_KEY\nfrom ecologits import EcoLogits\n\nEcoLogits.init()\n\nclass LLMConfiguration:\n    def __init__(self):\n        self.client = AzureOpenAI(\n            api_key=AZURE_OPENAI_KEY,\n            api_version=\"2024-03-01-preview\",\n            azure_endpoint=OPENAI_ENDPOINT\n        )\n        \n        self.default_params = {\n            \"model\": MODEL_NAME,\n            \"temperature\": 0,\n            \"response_format\": {\"type\": \"json_object\"},\n            \"max_tokens\": None\n        }\n        \n    def invoke(self, prompt):\n        response = self.client.chat.completions.create(\n            messages=[{\"role\": \"user\", \"content\": prompt}],\n            **self.default_params\n        )\n        return response","description":"Ce fichier configure et gère les interactions avec un modèle de langage (LLM) via l'API Azure OpenAI. Il initialise le client AzureOpenAI et définit une méthode pour envoyer des prompts et recevoir des réponses.","reutilisabilite":"La classe LLMConfiguration est hautement réutilisable pour toute application nécessitant des interactions avec un LLM via Azure. Elle encapsule la logique d'appel à l'API, rendant le code modulaire et facile à intégrer.","specificites_fonctionnelles":"Permet l'intégration d'un LLM dans des applications, facilitant l'interaction utilisateur via des prompts.","value_index":0.003787878787878788}
{"themes":"Appel à un LLM, Conception de prompts, Prise en compte de la frugalité, ","id_pepite":60,"equipe":"equipe_08_maidfm","langage":"PYTHON","is_api_idfm":0,"is_api_autres":0,"is_appel_llm":1,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":1,"is_geocoding":0,"is_angular":0,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_08_maidfm/Hackathon-IDFM-main/old/llm/llm_management.py","code":"from openai import AzureOpenAI\nfrom llm.keys import OPENAI_ENDPOINT, MODEL_NAME, AZURE_OPENAI_KEY\nfrom ecologits import EcoLogits\n\nEcoLogits.init()\n\nclass LLMConfiguration:\n    def __init__(self):\n        self.client = AzureOpenAI(\n            api_key=AZURE_OPENAI_KEY,\n            api_version=\"2024-03-01-preview\",\n            azure_endpoint=OPENAI_ENDPOINT\n        )\n        \n        self.default_params = {\n            \"model\": MODEL_NAME,\n            \"temperature\": 0,\n            \"response_format\": {\"type\": \"json_object\"},\n            \"max_tokens\": None\n        }\n        \n    def invoke(self, prompt):\n        response = self.client.chat.completions.create(\n            messages=[{\"role\": \"user\", \"content\": prompt}],\n            **self.default_params\n        )\n        return response","description":"Ce fichier configure et gère les interactions avec le modèle de langage Azure OpenAI. Il initialise le client avec les paramètres par défaut et fournit une méthode pour invoquer le modèle avec un prompt.","reutilisabilite":"La classe LLMConfiguration est hautement réutilisable pour toute application nécessitant des interactions avec un modèle de langage Azure OpenAI. Elle encapsule la logique d'appel et de configuration, facilitant ainsi l'intégration dans d'autres projets.","specificites_fonctionnelles":"Répond au besoin de gérer les interactions avec un modèle de langage, en fournissant une interface simple pour envoyer des prompts et recevoir des réponses.","value_index":0.003787878787878788}
{"themes":"Appel à un LLM, Création d\\'une interface utilisateur (IHM), Conception de prompts, ","id_pepite":55,"equipe":"equipe_08_maidfm - Hackathon-IDFM","langage":"PYTHON","is_api_idfm":0,"is_api_autres":0,"is_appel_llm":1,"is_creation_ihm":1,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":1,"is_geocoding":0,"is_angular":0,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_08_maidfm%20%-%20%Hackathon-IDFM/old/prompt_billettique.py","code":"def generate_custom_message(user_data):\n    prompt = f\"\"\"\n    Crée un message personnalisé pour l'utilisateur en fonction de ses informations d'abonnement :\n    - Abonnement : {user_data['billettique_type']}\n    - Fin de validité : {user_data['billettique_end_date']}\n    - Tickets restants : {user_data['billettique_tickets_left']}\n    Ne génère le message que si l'utilisateur a besoin d'être averti, par exemple :\n    - S'il reste moins de 2 tickets.\n    - Si l'abonnement expire dans moins de 7 jours.\n    Le message doit être court, il doit y avoir de la place pour plein de message dans l'écran\n    \"\"\"\n\n    response = llm_config.llm.invoke(prompt_test.format(input=prompt))\n    return response","description":"Génération de messages personnalisés pour les utilisateurs en fonction de leurs données d'abonnement en utilisant Azure OpenAI.","reutilisabilite":"Ce code est réutilisable pour toute application nécessitant la génération de messages personnalisés basés sur des données utilisateur.","specificites_fonctionnelles":"Permet de notifier les utilisateurs sur l'état de leur abonnement de manière personnalisée.","value_index":0.004285714285714286}
{"themes":"Appel à un LLM, Création d\\'une interface utilisateur (IHM), Conception de prompts, Génération de données, ","id_pepite":38,"equipe":"equipe_08_maidfm - Hackathon-IDFM-main","langage":"PYTHON","is_api_idfm":0,"is_api_autres":0,"is_appel_llm":1,"is_creation_ihm":1,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":1,"is_geocoding":0,"is_angular":0,"is_data_generation":1,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_08_maidfm%20%-%20%Hackathon-IDFM-main/config/prompt_billettique.py","code":"def generate_custom_message(user_data):\n    prompt = f\"\"\"\n    Crée un message personnalisé pour l'utilisateur en fonction de ses informations d'abonnement :\n    - Abonnement : {user_data['billettique_type']}\n    - Fin de validité : {user_data['billettique_end_date']}\n    - Tickets restants : {user_data['billettique_tickets_left']}\n    Ne génère le message que si l'utilisateur a besoin d'être averti, par exemple :\n    - S'il reste moins de 2 tickets.\n    - Si l'abonnement expire dans moins de 7 jours.\n    Le message doit être court, il doit y avoir de la place pour plein de message dans l'écran\n    \"\"\"\n\n    response = llm_config.invoke(prompt_test.format(input=prompt))\n    return response","description":"Cette fonction génère un message personnalisé pour un utilisateur en fonction de ses informations d'abonnement, en utilisant un modèle de langage (LLM) pour formuler le message.","reutilisabilite":"La fonction est réutilisable pour générer des messages personnalisés basés sur des conditions spécifiques d'abonnement, ce qui peut être adapté à d'autres contextes nécessitant des notifications personnalisées.","specificites_fonctionnelles":"Répond au besoin de notifier les utilisateurs sur l'état de leur abonnement de manière proactive.","value_index":0.005747126436781609}
{"themes":"Appel à un LLM, Création d\\'une interface utilisateur (IHM), Conception de prompts, Prise en compte de la frugalité, ","id_pepite":31,"equipe":"equipe_08_maidfm - Hackathon-IDFM-main","langage":"PYTHON","is_api_idfm":0,"is_api_autres":0,"is_appel_llm":1,"is_creation_ihm":1,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":1,"is_geocoding":0,"is_angular":0,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/resultats/repositories/equipe_08_maidfm/Hackathon-IDFM-main/Hackathon_équipe8/domain/llm/main.py","code":"from Hackathon_équipe8.domain.llm.llm_management import LLMConfiguration\nfrom Hackathon_équipe8.config.prompts import prompt_test\n\nllm_config = LLMConfiguration()\n\ninput = \"I am a human\"\nresponse = llm_config.invoke(prompt_test.format(input = input))\n\nprint(f'response: {response.choices[0].message.content}')\n\nprint(f'Impact energy: {response.impacts.energy.value.max} kWh')\nprint(f'Impact co2: {response.impacts.usage.gwp.value.max} CO2eq')","description":"Ce code initialise une configuration de modèle de langage (LLM) et invoque une réponse en utilisant un prompt formaté. Il affiche ensuite la réponse du modèle ainsi que des informations sur l'impact énergétique et CO2.","reutilisabilite":"Le code est précieux pour son abstraction de l'invocation d'un modèle de langage, ce qui permet de réutiliser facilement cette logique pour d'autres prompts ou configurations.","specificites_fonctionnelles":"Le code permet de tester l'interaction avec un modèle de langage et d'évaluer l'impact environnemental de l'utilisation de ce modèle.","value_index":0.00904977375565611}
{"themes":"Appel à un LLM, Création d\\'une interface utilisateur (IHM), Utilisation d\\'un référentiel d\\'événements, Conception de prompts, Génération de données, ","id_pepite":35,"equipe":"equipe_08_maidfm - Hackathon-IDFM-main","langage":"PYTHON","is_api_idfm":0,"is_api_autres":0,"is_appel_llm":1,"is_creation_ihm":1,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":1,"is_datalake":0,"is_rag":0,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":1,"is_geocoding":0,"is_angular":0,"is_data_generation":1,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_08_maidfm%20%-%20%Hackathon-IDFM-main/config/prompt_évènement.py","code":"def generate_custom_message(user_data, events):\n    if not events:\n        return \"\"\n\n    event_details = \"\\n\".join([\n        f\"- Événement : {event['Titre']}\\n  - Description : {event['Description']}\\n  - Lien : {event['URL canonique']}\"\n        for event in events\n    ])\n    user_interests_str = ', '.join(user_data['centres d\\'intérêts'])\n    prompt = f\"\"\"\n    Crée un message personnalisé pour l'utilisateur en fonction de ses centres d'intérêts et des événements disponibles en Île-de-France dans les prochains jours.\n    Les centres d'intérêts de l'utilisateur sont : {user_interests_str}\n    Voici une liste d'événements récents :\n    {event_details}\n    \"\"\"\n    response = llm_config.invoke(prompt_test.format(input=prompt))\n    return response","description":"Cette fonction génère un message personnalisé pour un utilisateur en fonction de ses centres d'intérêts et des événements disponibles, en utilisant un modèle de langage (LLM) pour formuler le message.","reutilisabilite":"La fonction est réutilisable pour créer des messages personnalisés basés sur les intérêts des utilisateurs et les événements, ce qui peut être adapté à d'autres contextes nécessitant des recommandations personnalisées.","specificites_fonctionnelles":"Répond au besoin de recommander des événements pertinents aux utilisateurs en fonction de leurs intérêts.","value_index":0.006640106241699867}
{"themes":"Appel à un LLM, Traitement audio ou vocal, ","id_pepite":6,"equipe":"equipe_05_mobilia","langage":"PYTHON","is_api_idfm":0,"is_api_autres":0,"is_appel_llm":1,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":1,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":0,"is_geocoding":0,"is_angular":0,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_05_mobilia/MobilIA-main/api/functions.py","code":"def transcribe_audio_with_openai(audio_path): ...","description":"Transcrit un fichier audio en texte en utilisant le modèle Whisper d'OpenAI.","reutilisabilite":"Utile pour les applications nécessitant la transcription automatique de l'audio, comme les services de sous-titrage ou de transcription de réunions.","specificites_fonctionnelles":"Facilite la transcription de contenu audio, essentiel pour l'accessibilité et l'archivage de données vocales.","value_index":0.04081632653061224}
{"themes":"Appel à un LLM, Traitement d\\'images, ","id_pepite":3,"equipe":"equipe_05_mobilia","langage":"PYTHON","is_api_idfm":0,"is_api_autres":0,"is_appel_llm":1,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":0,"is_image":1,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":0,"is_geocoding":0,"is_angular":0,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_05_mobilia/MobilIA-main/api/functions.py","code":"def analyze_image_with_openai(image_path): ...","description":"Cette fonction encode une image en base64, l'analyse via l'API OpenAI pour obtenir une description, et gère les erreurs potentielles.","reutilisabilite":"La fonction est utile pour toute application nécessitant une analyse d'image automatisée, et peut être intégrée dans des systèmes de reconnaissance d'image ou de transcription de texte.","specificites_fonctionnelles":"Permet l'analyse et la transcription de contenu d'image, ce qui est crucial pour l'accessibilité et l'interprétation de données visuelles.","value_index":0.043478260869565216}
{"themes":"Appel à un LLM, Traitement d\\'images, ","id_pepite":95,"equipe":"equipe_05_mobilia","langage":"PYTHON","is_api_idfm":0,"is_api_autres":0,"is_appel_llm":1,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":0,"is_image":1,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":0,"is_geocoding":0,"is_angular":0,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_05_mobilia/MobilIA-main/final.py","code":"client = OpenAI(api_key='XXX')\n\n# Fonction pour envoyer l'image encodée en base64 à l'API OpenAI et récupérer une description\ndef image_to_description_with_openai(image_path):\n    try:\n        print(\"Encodage de l'image en base64...\")\n        base64_image = encode_image_to_base64(image_path)\n\n        if not base64_image:\n            return \"Erreur lors de l'encodage de l'image.\"\n\n        print(\"Envoi de l'image encodée à OpenAI pour analyse...\")\n        response = client.chat.completions.create(\n            model=\"gpt-4o-mini\",\n            messages=[\n                {\n                    \"role\": \"user\",\n                    \"content\": [\n                        {\"type\": \"text\", \"text\": \"What's in this image? If there is some text, write the full transcript, keeping the same language.\"},\n                        {\n                            \"type\": \"image_url\",\n                            \"image_url\": {\n                                \"url\": f\"data:image/jpeg;base64,{base64_image}\"\n                            },\n                        },\n                    ],\n                }\n            ],\n            max_tokens=300,\n        )\n\n        # Récupération de la description générée\n        description = response.choices[0].message.content\n        print(f\"Description extraite par OpenAI : {description}\")\n        return description\n    except Exception as e:\n        print(f\"Erreur avec l'API OpenAI : {e}\")\n        return \"Une erreur est survenue lors de l'analyse de l'image.\"","description":"Ce code initialise un client OpenAI et définit une fonction pour envoyer une image encodée en base64 à l'API OpenAI afin d'obtenir une description de l'image.","reutilisabilite":"Ce code est réutilisable pour toute application nécessitant l'analyse d'images via l'API OpenAI, ce qui est utile pour des tâches de reconnaissance d'image ou de transcription de texte dans des images.","specificites_fonctionnelles":"Permet l'analyse d'images pour extraire des descriptions textuelles, ce qui peut être utilisé dans des applications d'accessibilité ou de gestion de contenu.","value_index":0.0013395847287340924}
{"themes":"Appel à un LLM, Traitement du langage naturel (NLP), ","id_pepite":119,"equipe":"equipe_09_alterego","langage":"PYTHON","is_api_idfm":0,"is_api_autres":0,"is_appel_llm":1,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":1,"is_websocket":0,"is_prompt_design":0,"is_geocoding":0,"is_angular":0,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_09_alterego/idfm_hackaton_2024-main/backend/api-llm/src/nlu.py","code":"from .client import Client\n\n\nclass Nlu:\n    def __init__(self):\n        self.client = Client()\n        self.client = self.client.get_client()\n        self.model = 'gpt-4o-mini'\n\n    def get_intentions_entites(self, message):\n        conversation_history = []\n        conversation_history.append(\n                \n            {\"role\": \"system\", \"content\":\n                \"\"\"\n                    Tu est un agent intelligent, ton role consiste a detecter si la demande de\n                    l'utilisateur concerne l'une des description suivantes:\n                    {\n                        {\n                            \"name\": \"Météo\",\n                            \"description\": \"Il est possible d'accéder à la météo en temps réel en \n                            utilisant l'API indiquée dans le champ url. Il faut indiquer une\n                             position en utilisant la latitude et la longitude. On peut obtenir le \n                             niveau de pluie, le niveau de neige, la vitesse du vent, la \n                             température.\",\n                            \"url\": \"https://api.openweathermap.org/data/2.5/weather\"\n                        },\n                        {\n                            \"name\": \"Liste des lignes\",\n                            \"description\": \"Il est possible d'accéder à la liste des lignes de \n                            transport en commun d'Île-de-France en lisant le fichier nommé dans le \n                            champ url. Pour chaque ligne, la liste contient l'identifiant \n                            commercial, l'identifiant administratif, son nom, si elle est\n                             accessible PMR, son mode de transport. Elle contient les lignes de\n                            bus, métro, RER, navette\n                             aéroport, tramway, funiculaire.\",\n                            \"url\": \"referentiel-des-lignes.parquet\"\n                        },\n                        {\n                            \"name\": \"Liste des arrêts\",\n                            \"description\": \"Il est possible d'accéder à la liste des arrêts en\n                             lisant le fichier nommé dans le champ url. Pour chaque arrêt, la liste \n                             contient ses coordonnées géographiques en latitude/longitude WGS 84 \n                             ainsi que Lambert-93, son identifiant, son nom, son mode de transport, \n                             le nom de sa commune, sa zone de tarif Navigo, si elle est accessible \n                             PMR.\",\n                            \"url\": \"referentiel-des-lignes.parquet\"\n                        },\n                        {\n                            \"name\": \"Correspondance arrêt-ligne\",\n                            \"description\": \"Il est possible d'accéder à la correspondance entre\n                             identifiant d'arrêt et identifiant de ligne commerciale en lisant le \n                             fichier nommé dans le champ url.\",\n                            \"url\": \"arrets-lignes.parquet\"\n                        },\n                        {\n                            \"name\": \"Relations arrêts\",\n                            \"description\": \"Il est possible d'accéder aux relations entre objets\n                             arrêt tels quel arrêt transporteur, arrêt, zone d'arrêts, zone de \n                             correspondance, pôle d'échanges, grâce à leurs identifiants. Il faut\n                            utiliser le fichier nommé dans le champ url.\",\n                            \"url\": \"relations.parquet\"\n                        }\n                }\n                Sinon demande à l'utilisateur de dmander une information à propos d'IDFM\"\n\n                \"\"\"})\n        conversation_history.append({\"role\": \"user\", \"content\": message})\n        response = self.client.chat.completions.create(\n            model=self.model,\n            messages=conversation_history,\n            temperature=0,\n        )\n        return response.choices[0].message.content","description":"Ce code utilise un modèle de langage pour détecter les intentions et entités dans un message utilisateur, en se basant sur des descriptions prédéfinies.","reutilisabilite":"Le code est hautement réutilisable pour toute application nécessitant une analyse des intentions et entités à l'aide d'un modèle de langage.","specificites_fonctionnelles":"Permet de déterminer si un message utilisateur correspond à des services ou données spécifiques, comme la météo ou les lignes de transport.","value_index":0.0004952947003467063}
{"themes":"Appel à un LLM, Utilisation de LangChain, ","id_pepite":47,"equipe":"equipe_04_mobiwize - ai-framework-main","langage":"JAVASCRIPT","is_api_idfm":0,"is_api_autres":0,"is_appel_llm":1,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":1,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":0,"is_geocoding":0,"is_angular":0,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_04_mobiwize%20%-%20%ai-framework-main/https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/blob/main/packages/ai-toolkit/src/registry/registry.ts","code":"import {AzureChatOpenAI} from \"@langchain/openai\";\n\nexport const llm = new AzureChatOpenAI({\n  azureOpenAIEndpoint: process.env.AZURE_OPENAI_ENDPOINT,\n  azureOpenAIApiKey: process.env.AZURE_OPENAI_API_KEY,\n  azureOpenAIApiDeploymentName: process.env.AZURE_OPENAI_MODELS,\n  azureOpenAIApiVersion: process.env.AZURE_OPENAI_API_VERSION,\n  model: process.env.AZURE_OPENAI_MODELS,\n  temperature: 0.1,\n});","description":"Ce code initialise un modèle de langage (LLM) Azure OpenAI pour des interactions de chat, en configurant les paramètres d'API et de modèle.","reutilisabilite":"Ce code est réutilisable pour toute application nécessitant des interactions de chat basées sur Azure OpenAI, avec des paramètres configurables pour le modèle et l'API.","specificites_fonctionnelles":"Facilite l'intégration de capacités de chat IA dans des applications, avec des paramètres ajustables pour le modèle et l'API.","value_index":0.005012531328320802}
{"themes":"Appel à un LLM, Utilisation de LangChain, ","id_pepite":61,"equipe":"equipe_08_maidfm","langage":"PYTHON","is_api_idfm":0,"is_api_autres":0,"is_appel_llm":1,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":1,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":0,"is_geocoding":0,"is_angular":0,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_08_maidfm/Hackathon-IDFM-main/Hackathon_équipe8/domain/llm/llm_management_old.py","code":"from langchain_openai import AzureChatOpenAI\nfrom llm.keys import OPENAI_ENDPOINT, MODEL_NAME, AZURE_OPENAI_KEY\n\nclass LLMConfiguration:\n    def __init__(self):\n        self.llm = AzureChatOpenAI(\n            model=MODEL_NAME,\n            temperature=0,\n            max_tokens=None,\n            timeout=None,\n            max_retries=2,\n            api_key=AZURE_OPENAI_KEY,\n            azure_endpoint=OPENAI_ENDPOINT,\n            api_version=\"2024-03-01-preview\"\n        )\n        self.llm.bind(response_format={\"type\": \"json_object\"})","description":"Ce fichier configure une ancienne version de la gestion des interactions avec un LLM via l'API Azure OpenAI, utilisant la bibliothèque langchain_openai.","reutilisabilite":"Bien que ce soit une version ancienne, la classe LLMConfiguration reste réutilisable pour des applications nécessitant une interaction avec un LLM. Elle montre une approche alternative pour configurer et utiliser l'API Azure OpenAI.","specificites_fonctionnelles":"Fournit une configuration alternative pour l'intégration d'un LLM, utile pour comparer différentes approches d'implémentation.","value_index":0.003738317757009346}
{"themes":"Appel à un LLM, Utilisation de LangChain, ","id_pepite":62,"equipe":"equipe_08_maidfm","langage":"PYTHON","is_api_idfm":0,"is_api_autres":0,"is_appel_llm":1,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":1,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":0,"is_geocoding":0,"is_angular":0,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_08_maidfm/Hackathon-IDFM-main/old/llm/llm_management_old.py","code":"from langchain_openai import AzureChatOpenAI\nfrom llm.keys import OPENAI_ENDPOINT, MODEL_NAME, AZURE_OPENAI_KEY\n\nclass LLMConfiguration:\n    def __init__(self):\n        self.llm = AzureChatOpenAI(\n            model=MODEL_NAME,\n            temperature=0,\n            max_tokens=None,\n            timeout=None,\n            max_retries=2,\n            api_key=AZURE_OPENAI_KEY,\n            azure_endpoint=OPENAI_ENDPOINT,\n            api_version=\"2024-03-01-preview\"\n        )\n        self.llm.bind(response_format={\"type\": \"json_object\"})","description":"Ce fichier configure une instance de AzureChatOpenAI pour interagir avec le modèle de langage. Il initialise le modèle avec des paramètres spécifiques et lie le format de réponse.","reutilisabilite":"La classe LLMConfiguration est réutilisable pour configurer et interagir avec AzureChatOpenAI. Elle offre une abstraction pour gérer les paramètres de connexion et de réponse, facilitant l'intégration dans d'autres systèmes.","specificites_fonctionnelles":"Fournit une configuration prête à l'emploi pour interagir avec AzureChatOpenAI, répondant aux besoins de gestion des interactions avec un modèle de langage.","value_index":0.003738317757009346}
{"themes":"Appel à un LLM, Utilisation de LangChain, Conception de prompts, ","id_pepite":114,"equipe":"equipe_10_ivoice","langage":"PYTHON","is_api_idfm":0,"is_api_autres":0,"is_appel_llm":1,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":1,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":1,"is_geocoding":0,"is_angular":0,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_10_ivoice/ivoice-main/ivoice-main/src/langchain_openai.py","code":"import openai\nimport json\nimport os\nfrom langchain.chat_models import AzureChatOpenAI\nfrom langchain.schema import HumanMessage\n\nfrom langchain import LLMChain\nfrom langchain import PromptTemplate\nfrom dotenv import load_dotenv\n\nload_dotenv()\n\ndef generate_messages(trajets_alternatifs: dict, infos_incident: str, ligne_incident: str):\n    openai_api_version=os.getenv('AZURE_OPENAI_API_VERSION')\n    deployment_name=os.getenv('AZURE_OPENAI_MODELS')\n    openai_api_type=\"azure\"\n\n    llm = AzureChatOpenAI(\n        openai_api_version=openai_api_version,\n        deployment_name=deployment_name,\n        openai_api_type=openai_api_type\n    )\n\n    template = f\"\"\"\n    Ta mission est de générer des messages personnalisés pour chacune des stations d'une ligne de métro perturbée.\n    Ces messages doivent informer et rassurer.\n\n    Pour générer ces messages tu t'appuieras exclusivement sur les données suivantes:\n\n    Le message d'incident: {infos_incident}\n    La ligne impactée par l'incident: {ligne_incident}\n    Les itinéraires alternatifs proposés pour chacun des stations de la ligne: {trajets_alternatifs}\n\n    Pour chaque message tu commences par énoncer la nature de l'incident et la station qui est touchée. Par exemple :\n    Si le message incident est \"Métro 9 : Bagage oublié sur un quai - Trafic interrompu\"\n    Et que la ligne impactée est \"Métro 9\"\n    Tu écriras: \"Bonjour chers voyageurs, le trafic est interrompu sur la ligne 9 suite à un bagage oublié sur un quai.\"\n\n    Puis, rassure-les en indiquant que tu vas les aider à trouver le meilleur itinéraire. Par exemple :\n    Nous sommes désolés pour cet incident, mais nous sommes là pour vous guider jusqu’à votre destination.\n\n    Situe dans quelle station les voyageurs se trouvent. Par exemple :\n    Si la station actuellement traitée est \"Pont de Sèvres\"\n    Vous êtes actuellement à la station Pont de Sèvres de la ligne 9. Voici les itinéraires possibles selon votre destination.\n\n    Maintenant, tu vas expliquer, itinéraire par itinéraire, comment se déplacer. Tu vas utiliser la même structure d'explication pour chacun d’eux.\n\n    Énonce la direction de l’itinéraire pour les voyageurs concernés. Par exemple :\n    Si le itinerary_type dans l'itinéraire alternatif est: Nord-Ouest de Paris\n    Tu écriras: Pour tous les voyageurs en direction du Nord-Ouest de Paris.\n\n    Énonce la station et le numéro de ligne recommandé. Par exemple :\n    Si la route de l'itinéraire alternatif est: {{\"start\": \"Pont de Sèvres\", \"end\": \"Marcel Sembat\", \"ligne\": \"Métro 9\"}}\n    Empruntez la ligne 9 pour rejoindre la station Marcel Sembat.\n\n    Fournis les résultats au format JSON, avec comme clés toutes les stations et comme valeur le message qui lui est destiné.\n    \"\"\"\n\n    llm_var = llm([HumanMessage(content=template)])\n\n    json_content = llm_var.content.strip(\"\").strip(\",\")\n    print(json_content)\n\n    try:\n        result = json.loads(json_content)\n    except:\n        fix_prompt = f\"The folloxing JSON string is invalid, fix it and return it as valid JSON: {json_content}\"\n        fixed_json = llm([HumanMessage(content=fix_prompt)])\n        result = json.loads(fixed_json)\n\n    return result\n\nif __name__ == \"__main__\":\n    ligne_incident = \"Métro 9\"\n    trajets_alternatifs = {\"Fake_station\": [{\"itinary_type\": \"centre Paris\",\n                                            \"routes\" : [{\"start\" : \"Démocrate\", \"end\" : \"Balna\", \"ligne\": \"1\"}]}],\n                        \"Fake_station_2\": [{\"itinary_type\" : \"Paris Nord-Est\",\n                                            \"routes\" : [{\"start\" : \"Longitude\", \"end\" : \"Voltour\", \"ligne\": \"10\"}]}],\n                            }\n    infos_incident = \"\"\"\n        Le trafic est interrompu entre Porte de Montreuil et Mairie de Montreuil en raison d'un bagage oublié sur un quai .\n        Heure de reprise estimée : 21:30.\n        Nous vous invitons à emprunter des itinéraires alternatifs et à vous rapprocher de nos agents.\n        Plus d'informations sur le site ratp.fr\n    \"\"\"\n    messages = generate_messages(trajets_alternatifs, infos_incident, ligne_incident)\n    print(messages)","description":"Ce code utilise l'API Azure OpenAI pour générer des messages personnalisés concernant des perturbations sur une ligne de métro, en utilisant des itinéraires alternatifs et des informations d'incident.","reutilisabilite":"Le code est hautement réutilisable pour générer des messages personnalisés en cas de perturbations, grâce à l'utilisation de modèles de langage et de prompts structurés.","specificites_fonctionnelles":"Le code répond au besoin de communication rapide et personnalisée en cas de perturbations sur les lignes de transport, en fournissant des messages clairs et informatifs aux voyageurs.","value_index":0.00073117231294175}
{"themes":"Appel à un LLM, Utilisation de Retrieval-Augmented Generation (RAG), Conception de prompts, ","id_pepite":49,"equipe":"equipe_04_mobiwize","langage":"JAVASCRIPT","is_api_idfm":0,"is_api_autres":0,"is_appel_llm":1,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":1,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":1,"is_geocoding":0,"is_angular":0,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_04_mobiwize/ai-framework-main/packages/ai-toolkit/src/graphs/rag/index.ts","code":"export const createResearchPlan = async (state: typeof RetrievalGraphAnnotation.State, config: LangGraphRunnableConfig): Promise<RetrievalGraphReturnType> => { const modelWithTool = llm.withStructuredOutput(z.object({ steps: z.array(z.string()) }), {name: \"create_plan\"}); const messages = [ {role: \"system\", content: getDefaultPromptConfig().researchPlanSystemPrompt}, ...state.messages ]; const response = await modelWithTool.invoke(messages); const lastMessage = state.messages[state.messages.length - 1]; return { steps: response.steps, documents: undefined, query: lastMessage?.content as string, }; };","description":"Cette fonction crée un plan de recherche en utilisant un modèle de langage pour structurer les étapes de recherche basées sur les messages d'entrée.","reutilisabilite":"Le code est modulaire et utilise un modèle de langage pour générer dynamiquement un plan de recherche, ce qui le rend réutilisable pour différents types de requêtes de recherche.","specificites_fonctionnelles":"Répond au besoin de créer un plan de recherche structuré basé sur les requêtes utilisateur.","value_index":0.004942339373970346}
{"themes":"Appel à un LLM, Utilisation de Retrieval-Augmented Generation (RAG), Utilisation de LangChain, ","id_pepite":22,"equipe":"equipe_08_maidfm","langage":"PYTHON","is_api_idfm":0,"is_api_autres":0,"is_appel_llm":1,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":1,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":1,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":0,"is_geocoding":0,"is_angular":0,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_08_maidfm/Hackathon-IDFM-main/notebooks/HIAM2024","code":"from langchain_openai import AzureOpenAIEmbeddings\n\nembedding_model = AzureOpenAIEmbeddings(\n    **azure_open_ai_parameters,\n    model=\"text-embedding-3-large\", # Voir comment pointer sur variables d'environnement ou sur Vault\n)","description":"Ce code initialise un modèle d'embedding basé sur OpenAI, hébergé sur Azure, pour générer des vecteurs à partir de documents.","reutilisabilite":"Utile pour les applications nécessitant des embeddings de texte, notamment pour l'indexation et la recherche dans des bases de données vectorielles.","specificites_fonctionnelles":"Permet de transformer des documents en vecteurs pour une indexation efficace dans une base de données vectorielle.","value_index":0.013157894736842105}
{"themes":"Appel à un LLM, Utilisation de Retrieval-Augmented Generation (RAG), Utilisation de LangChain, ","id_pepite":65,"equipe":"equipe_04_mobiwize - ai-framework-main","langage":"JAVASCRIPT","is_api_idfm":0,"is_api_autres":0,"is_appel_llm":1,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":1,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":1,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":0,"is_geocoding":0,"is_angular":0,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_04_mobiwize%20%-%20%ai-framework-main/https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/blob/main/packages/ai-toolkit/src/rag/elastic.ts","code":"import {type ElasticClientArgs, ElasticVectorSearch,} from \"@langchain/community/vectorstores/elasticsearch\";\nimport {AzureOpenAIEmbeddings} from \"@langchain/openai\";\nimport {Client, type ClientOptions} from \"@elastic/elasticsearch\";\nimport * as process from \"node:process\";\n\nexport const embeddings = new AzureOpenAIEmbeddings({\n  azureOpenAIApiDeploymentName: \"text-embedding-3-large\",\n  azureOpenAIApiInstanceName: \"dlb-team04-prd-oai01\",\n  azureOpenAIApiKey: process.env.AZURE_OPENAI_API_KEY,\n  azureOpenAIApiVersion: process.env.AZURE_OPENAI_API_VERSION,\n  model: \"text-embedding-3-large\",\n});\n\n\nconst config: ClientOptions = {\n  node: process.env.ELASTIC_URL ?? \"https://127.0.0.1:9200\",\n};\n\nconfig.auth = {\n  apiKey: process.env.ELASTIC_API_KEY as string,\n};\n\nconst clientArgs: ElasticClientArgs = {\n  client: new Client(config),\n  indexName: \"idfm-eq4\"\n};\n\nexport const vectorStore = new ElasticVectorSearch(embeddings, clientArgs);","description":"Ce code configure et initialise une recherche vectorielle ElasticSearch en utilisant des embeddings générés par Azure OpenAI. Il établit une connexion avec un client ElasticSearch en utilisant des configurations d'authentification et de connexion spécifiques.","reutilisabilite":"Ce code est réutilisable pour toute application nécessitant une recherche vectorielle basée sur des embeddings OpenAI, intégrant ElasticSearch pour le stockage et la recherche de vecteurs.","specificites_fonctionnelles":"Permet l'intégration de capacités de recherche vectorielle avancées dans des applications utilisant ElasticSearch et OpenAI.","value_index":0.0031914893617021275}
{"themes":"Appel à un LLM, Validation des données, Conception de prompts, ","id_pepite":77,"equipe":"equipe_01_accit_falc","langage":"PYTHON","is_api_idfm":0,"is_api_autres":0,"is_appel_llm":1,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":1,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":1,"is_geocoding":0,"is_angular":0,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_01_accit_falc/app/models/config.py","code":"from functools import cache\nfrom typing import Type\n\nfrom pydantic import BaseModel, ConfigDict\nfrom pydantic_settings import (\n    BaseSettings,\n    PydanticBaseSettingsSource,\n    YamlConfigSettingsSource,\n)\n\n\nclass ModelConfig(BaseModel):\n    model_config = ConfigDict(extra=\"allow\", protected_namespaces=tuple())\n    model: str\n    system_prompt: str\n\n\nclass LLMConfig(BaseModel):\n    model_config = ConfigDict(extra=\"allow\", protected_namespaces=tuple())\n    model_class: str\n\n\nclass DBConfig(BaseModel):\n    url: str\n    echo: bool = False\n\n\nclass Config(BaseSettings):\n\n    @classmethod\n    def settings_customise_sources(\n        cls,\n        settings_cls: Type[BaseSettings],\n        init_settings: PydanticBaseSettingsSource,\n        env_settings: PydanticBaseSettingsSource,\n        dotenv_settings: PydanticBaseSettingsSource,\n        file_secret_settings: PydanticBaseSettingsSource,\n    ) -> tuple[PydanticBaseSettingsSource, ...]:\n        return (\n            init_settings,\n            YamlConfigSettingsSource(settings_cls, yaml_file=\"config.yaml\"),\n            env_settings,\n            dotenv_settings,\n            file_secret_settings,\n        )\n\n    falceur: ModelConfig\n    falc_scorer: ModelConfig\n    db: DBConfig\n    models: dict[str, LLMConfig]\n\n\n@cache\ndef get_config():\n    return Config()","description":"Ce fichier définit des configurations pour différents composants de l'application, y compris les modèles de langage (LLM), la base de données, et les modèles spécifiques à l'application. Il utilise Pydantic pour la validation et la gestion des configurations.","reutilisabilite":"Le code est hautement réutilisable grâce à son abstraction et à sa modularité. Il permet de gérer les configurations de manière centralisée et flexible, facilitant l'intégration avec différents modèles de langage et bases de données.","specificites_fonctionnelles":"Le code permet de configurer et de personnaliser facilement les modèles de langage et les connexions à la base de données, ce qui est essentiel pour le bon fonctionnement de l'application.","value_index":0.002277904328018223}
{"themes":"Conception de prompts, ","id_pepite":25,"equipe":"equipe_01_accit_falc","langage":"PYTHON","is_api_idfm":0,"is_api_autres":0,"is_appel_llm":0,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":1,"is_geocoding":0,"is_angular":0,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_01_accit_falc/app/core/falcer/base.py","code":"def score_a_text(model: BaseChatModel, system_prompt: str, user_prompt: str) -> dict: ...","description":"Cette fonction évalue un texte en utilisant un modèle de chat et retourne un score sous forme de dictionnaire.","reutilisabilite":"La fonction est utile pour évaluer des textes générés, ce qui peut être réutilisé dans divers contextes nécessitant une évaluation qualitative.","specificites_fonctionnelles":"Fournit une évaluation des textes, ce qui est crucial pour ajuster et améliorer les modèles de génération de texte.","value_index":0.011235955056179775}
{"themes":"Conception de prompts, ","id_pepite":27,"equipe":"equipe_01_accit_falc","langage":"PYTHON","is_api_idfm":0,"is_api_autres":0,"is_appel_llm":0,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":1,"is_geocoding":0,"is_angular":0,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_01_accit_falc/app/core/falcer/base.py","code":"def falcate_a_text(model: BaseChatModel, system_prompt: str, user_prompt: str) -> str: ...","description":"Cette fonction utilise un modèle de chat pour générer une réponse à partir d'un prompt utilisateur et d'un prompt système.","reutilisabilite":"La fonction est modulaire et peut être réutilisée pour intégrer différents modèles de chat en modifiant simplement les prompts et le modèle.","specificites_fonctionnelles":"Permet de générer des réponses textuelles basées sur des prompts, ce qui est essentiel pour des applications de simplification de texte.","value_index":0.011111111111111112}
{"themes":"Création d\\'une API, ","id_pepite":34,"equipe":"equipe_01_accit_falc","langage":"PYTHON","is_api_idfm":0,"is_api_autres":0,"is_appel_llm":0,"is_creation_ihm":0,"is_creation_api":1,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":0,"is_geocoding":0,"is_angular":0,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_01_accit_falc/app/api/routes/__init__.py","code":"from fastapi import APIRouter\n\nfrom .falc import router as router_falc\n\napi_router = APIRouter()\napi_router.include_router(router_falc, tags=[\"falc\"])","description":"Ce code initialise un routeur API FastAPI et inclut un sous-routeur pour les routes FALC (Facile à Lire et à Comprendre).","reutilisabilite":"Le routeur API est un composant modulaire qui peut être facilement étendu pour inclure d'autres sous-routeurs, facilitant ainsi l'organisation et la gestion des routes dans une application FastAPI.","specificites_fonctionnelles":"Permet de structurer les routes de l'application en séparant les fonctionnalités FALC, ce qui est essentiel pour une application modulaire.","value_index":0.006666666666666667}
{"themes":"Création d\\'une API, ","id_pepite":36,"equipe":"equipe_01_accit_falc","langage":"PYTHON","is_api_idfm":0,"is_api_autres":0,"is_appel_llm":0,"is_creation_ihm":0,"is_creation_api":1,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":0,"is_geocoding":0,"is_angular":0,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_01_accit_falc/setup-env.py","code":"def create_directory_structure():\n    ...\n\ndef create_config_files():\n    ...\n\ndef initialize_git():\n    ...\n\ndef setup_virtual_environment():\n    ...\n\ndef main():\n    ...","description":"Ce script initialise un projet FastAPI avec une structure standard, crée des fichiers de configuration, initialise un dépôt git et configure un environnement virtuel.","reutilisabilite":"Le script est hautement réutilisable pour initialiser rapidement de nouveaux projets FastAPI avec une structure de base cohérente et des configurations standardisées.","specificites_fonctionnelles":"Le script répond au besoin fonctionnel d'automatiser la configuration initiale d'un projet FastAPI, ce qui est essentiel pour les équipes de développement cherchant à standardiser leurs environnements de travail.","value_index":0.005847953216374269}
{"themes":"Création d\\'une API, ","id_pepite":40,"equipe":"equipe_09_alterego - idfm_hackaton_2024","langage":"PYTHON","is_api_idfm":0,"is_api_autres":0,"is_appel_llm":0,"is_creation_ihm":0,"is_creation_api":1,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":0,"is_geocoding":0,"is_angular":0,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_09_alterego/idfm_hackaton_2024-main%20%-%20%idfm_hackaton_2024/backend/api-ml-model/src/api_mlmodel/__main__.py","code":"import uvicorn\nfrom idfmhk24.app import app\n\ndef main():\n    print(\"Starting FastAPI server...\")\n    uvicorn.run(app, host=\"0.0.0.0\", port=8000)\n\nif __name__ == \"__main__\":\n    main()","description":"Lancement d'un serveur FastAPI en utilisant Uvicorn pour héberger l'application web.","reutilisabilite":"Ce code est réutilisable pour démarrer des applications web basées sur FastAPI, un framework populaire pour créer des APIs rapides et performantes.","specificites_fonctionnelles":"Permet de déployer une application web, ce qui est essentiel pour exposer des services de mobilité via une API.","value_index":0.00546448087431694}
{"themes":"Création d\\'une API, ","id_pepite":45,"equipe":"equipe_01_accit_falc","langage":"PYTHON","is_api_idfm":0,"is_api_autres":0,"is_appel_llm":0,"is_creation_ihm":0,"is_creation_api":1,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":0,"is_geocoding":0,"is_angular":0,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_01_accit_falc/fastapi.py","code":"app = FastAPI(\n    title=\"IDFM accessible text API\",\n    description=\"\"\"\n    Une API pour simplifier des textes en FALC.\n    ...\n    \"\"\",\n    version=\"1.0.0\",\n)\n\napp.include_router(api_router)","description":"Ce fichier initialise une application FastAPI pour une API qui simplifie les textes en FALC (Facile à Lire et à Comprendre).","reutilisabilite":"La structure de l'application FastAPI est réutilisable pour créer d'autres APIs avec des fonctionnalités similaires, en particulier celles nécessitant une interface utilisateur pour simplifier les textes.","specificites_fonctionnelles":"L'application répond au besoin de simplification de texte pour les utilisateurs ayant des difficultés de compréhension, ce qui est crucial pour l'accessibilité numérique.","value_index":0.005208333333333333}
{"themes":"Création d\\'une API, ","id_pepite":56,"equipe":"equipe_09_alterego","langage":"PYTHON","is_api_idfm":0,"is_api_autres":0,"is_appel_llm":0,"is_creation_ihm":0,"is_creation_api":1,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":0,"is_geocoding":0,"is_angular":0,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_09_alterego/idfm_hackaton_2024-main/backend/api-ml-model/src/api_mlmodel/idfmhk24.py","code":"from fastapi import FastAPI\n\napp = FastAPI()\n\n\n@app.get(\"/\")\ndef read_root():\n    return {\"message\": \"Hello, FastAPI!\"}\n\n\n@app.get(\"/items/{item_id}\")\ndef read_item(item_id: int, q: str = None):\n    return {\"item_id\": item_id, \"q\": q}","description":"Ce code initialise une application FastAPI avec deux endpoints : un endpoint racine qui retourne un message de bienvenue et un autre qui retourne un item basé sur un identifiant et un paramètre optionnel.","reutilisabilite":"Ce code est un exemple de base pour démarrer une API avec FastAPI, ce qui est utile pour créer rapidement des services web RESTful.","specificites_fonctionnelles":"Fournit une structure de base pour une API RESTful, ce qui est essentiel pour le développement de services web.","value_index":0.004273504273504274}
{"themes":"Création d\\'une API, ","id_pepite":82,"equipe":"equipe_01_accit_falc","langage":"PYTHON","is_api_idfm":0,"is_api_autres":0,"is_appel_llm":0,"is_creation_ihm":0,"is_creation_api":1,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":0,"is_geocoding":0,"is_angular":0,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_01_accit_falc/test-swagger.py","code":"class TransportType(str, Enum):\n    METRO = \"metro\"\n    BUS = \"bus\"\n    RER = \"rer\"\n    TRAM = \"tram\"\n\nclass Station(BaseModel):\n    id: int\n    name: str\n    transport_type: str\n    accessible: bool\n    lines: List[str]\n\n@app.get(\"/stations\", ...)\nasync def get_stations(...):\n    ...\n\n@app.get(\"/stations/{station_id}\", ...)\nasync def get_station(...):\n    ...\n\n@app.get(\"/search\", ...)\nasync def search_stations(...):\n    ...\n\n@app.get(\"/transport-types\", ...)\nasync def get_transport_types():\n    ...","description":"Ce fichier définit une API FastAPI pour obtenir des informations sur les stations de transport à Paris, avec des fonctionnalités de recherche et de filtrage.","reutilisabilite":"Les modèles de données et les routes API sont réutilisables pour d'autres projets nécessitant des fonctionnalités similaires de gestion et de recherche de données de transport.","specificites_fonctionnelles":"L'API répond aux besoins de gestion et de recherche d'informations sur les stations de transport, ce qui est essentiel pour les applications de mobilité urbaine.","value_index":0.001984126984126984}
{"themes":"Création d\\'une API, ","id_pepite":120,"equipe":"equipe_01_accit_falc","langage":"PYTHON","is_api_idfm":0,"is_api_autres":0,"is_appel_llm":0,"is_creation_ihm":0,"is_creation_api":1,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":0,"is_geocoding":0,"is_angular":0,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_01_accit_falc/app/api/routes/falc.py","code":"from fastapi import APIRouter\n\nfrom app.core.falcer.base import falc_text_score, falcate\nfrom app.core.falcer.understood import get_all_falc_feedback, store_falc_feedback\nfrom app.models.falc_understood import FalcFeedBack, FalcUnderstood\nfrom app.models.in_text import FalcText, NormalText\nfrom app.models.score_falceur import FalcScore\n\nrouter = APIRouter()\n\n\n@router.post(\"/text_to_falc\")\ndef text_to_falc(in_text: NormalText) -> str:\n    \"\"\"Transforme un texte en version FALC.\n\n    Ce point de terminaison permet de simplifier un texte en une version facile\n    à lire et à comprendre.\n    Le texte ainsi simplifié peut être compris par les personnes handicapées\n    mentales, mais aussi par d'autres comme les personnes dyslexiques,\n    malvoyantes, les personnes âgées, les personnes qui maîtrisent mal le\n    français.\n    \"\"\"\n    return falcate(in_text.text)\n\n\n@router.post(\"/score_falc\")\ndef score_falc_isation(in_text: FalcText) -> FalcScore:\n    \"\"\"Mesure la qualité de la FALCisation d'un texte.\n\n    Ce point de terminaison permet de noter un texte fourni sur sa facilité à\n    être lu et compris. Ce score sera exprimé en pourcentage (entre 0% et 100%).\n    Plus le pourcentage est bas, plus le texte fourni est loin de suivre les\n    règles FALC (FAcile à Lire et à Comprendre).\n    \"\"\"\n    return falc_text_score(in_text.falc_text)\n\n\n@router.post(\"/is_text_understood\")\ndef understood_falc(data: FalcUnderstood) -> None:\n    \"\"\"Indique si un texte falc a été compris ou pas.\n\n    Ce point de terminaison permet de vérifier si un texte FALCisé est bien\n    compris. La requête sera stocké dans une base de données pour permettre\n    aux prochaines FALCification d'être plus facile à comprendre.\n    \"\"\"\n    return store_falc_feedback(data)\n\n\n@router.get(\"/get_user_feedbacks\")\ndef get_feedbacks() -> list[FalcFeedBack]:\n    \"\"\"Récupère tous les retours utilisateurs sur la FALCisation.\n\n    Ce point de terminaison permet de récupérer tous les retours utilisateurs\n    sur la qualité de la FALCisation d'un texte.\n    \"\"\"\n    return get_all_falc_feedback()","description":"Ce fichier définit plusieurs routes API utilisant FastAPI pour transformer un texte en version FALC (Facile à Lire et à Comprendre), évaluer la qualité de cette transformation, vérifier la compréhension du texte transformé, et récupérer les retours utilisateurs.","reutilisabilite":"Les fonctions sont bien définies et encapsulées, ce qui permet de les réutiliser dans d'autres projets nécessitant des transformations de texte en FALC. L'utilisation de FastAPI facilite l'intégration dans d'autres services web.","specificites_fonctionnelles":"Le code répond à des besoins d'accessibilité en transformant des textes pour les rendre plus compréhensibles par des personnes ayant des difficultés de lecture, ce qui est essentiel pour l'inclusion numérique.","value_index":0.00048262548262548264}
{"themes":"Création d\\'une API, Traitement du langage naturel (NLP), ","id_pepite":80,"equipe":"equipe_09_alterego","langage":"PYTHON","is_api_idfm":0,"is_api_autres":0,"is_appel_llm":0,"is_creation_ihm":0,"is_creation_api":1,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":1,"is_websocket":0,"is_prompt_design":0,"is_geocoding":0,"is_angular":0,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_09_alterego/idfm_hackaton_2024-main/backend/api-llm/src/main.py","code":"from fastapi import FastAPI, Request\nfrom fastapi.responses import JSONResponse\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom pydantic import BaseModel\nfrom .nlu import Nlu\n\napp = FastAPI()\n\n# Need to specify the list of ports, else it won't work with only \"*\"\norigins = [\n    \"http://localhost\",\n    \"http://localhost:8080\",\n    \"http://localhost:5173\",\n    \"http://10.244.1.53:5173\",\n    \"*\"\n]\n\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=origins,\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n\nnlu = Nlu()\n\nclass MessageRequest(BaseModel):\n    message: str\n\n@app.post(\"/get_intentions_entites\")\nasync def get_intentions_entites(request: MessageRequest):\n    answer = nlu.get_intentions_entites(request.message)\n    return JSONResponse(content={\"answer\": answer})\n\nif __name__ == \"__main__\":\n    import uvicorn\n    uvicorn.run(app, host=\"0.0.0.0\", port=8001)","description":"Ce code met en place une API FastAPI avec un point de terminaison pour analyser les intentions et entités d'un message utilisateur en utilisant un module NLU.","reutilisabilite":"La structure de l'API est modulaire et peut être étendue pour inclure d'autres fonctionnalités d'analyse de langage naturel.","specificites_fonctionnelles":"Fournit un service web pour l'analyse des intentions et entités des messages utilisateurs.","value_index":0.002178649237472767}
{"themes":"Création d\\'une interface utilisateur (IHM), ","id_pepite":87,"equipe":"equipe_07_tranquiliscore","langage":"JAVASCRIPT","is_api_idfm":0,"is_api_autres":0,"is_appel_llm":0,"is_creation_ihm":1,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":0,"is_geocoding":0,"is_angular":0,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_07_tranquiliscore/tranquili-score-main/Documents/t-app-js/script.js","code":"const gares = [\n    { name: \"RER A\", danger: \"Élevé\" },\n    { name: \"RER B\", danger: \"Moyen\" },\n    { name: \"RER C\", danger: \"Bas\" },\n  ];\n  \n  const container = document.querySelector(\".gares-container\");\n  \n  gares.forEach((gare) => {\n    const gareElement = document.createElement(\"div\");\n    gareElement.classList.add(\"gare\");\n    gareElement.innerHTML = `\n      <span class=\"gare-icon\">🚇</span>\n      <span class=\"gare-name\">${gare.name}</span>\n      <span class=\"gare-danger\">⚠️ Niveau : ${gare.danger}</span>\n    `;\n    container.appendChild(gareElement);\n  });","description":"Ce code crée dynamiquement des éléments HTML pour afficher une liste de gares avec leur niveau de dangerosité. Chaque gare est représentée par un div contenant des informations sur le nom et le niveau de danger.","reutilisabilite":"Le code est réutilisable pour générer dynamiquement des listes d'éléments HTML à partir de données structurées, ce qui est utile pour les interfaces utilisateur interactives.","specificites_fonctionnelles":"Le code répond au besoin de visualiser des informations sur les gares et leur dangerosité de manière claire et interactive.","value_index":0.0017605633802816902}
{"themes":"Création d\\'une interface utilisateur (IHM), Appel à Whisper (audio), Traitement audio ou vocal, Traitement d\\'images, ","id_pepite":97,"equipe":"equipe_02_elevate_us","langage":"PYTHON","is_api_idfm":0,"is_api_autres":0,"is_appel_llm":0,"is_creation_ihm":1,"is_creation_api":0,"is_appel_whisper":1,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":1,"is_image":1,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":0,"is_geocoding":0,"is_angular":0,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_02_elevate_us/accessibility-waze-main/main.py","code":"import streamlit as st\nfrom back import get_all_zdc, get_list_of_equipements, get_accessibilite\nfrom edit_grievances import add_grievances\nimport time\nfrom pathlib import Path\nimport whisper\nfrom add_state_to_equipements import (\n    AVAILABLE,\n    UNAVAILABLE,\n    UNCERTAIN_AVAILABLE,\n    UNCERTAIN_UNAVAILABLE,\n    UNCERTAIN,\n)\n\nst.set_page_config(page_title=\"Hackathon accessibilité\")\n\n@st.cache_resource\ndef get_whisper():\n    return whisper.load_model(\"base\")\n\n@st.dialog(\"Signalement\")\ndef grieve(key, supposed_state):\n    left, right = st.columns([0.8, 0.2])\n    text = left.text_area(\"décrivez la situation (optionnel)\")\n    audio = right.audio_input(\"\", key=\"audio_input_\" + key)\n    if audio:\n        with open(\"audio.wav\", \"wb\") as f:\n            f.write(audio.getbuffer())\n        text = get_whisper().transcribe(\"audio.wav\", language=\"fr\", fp16=False)[\"text\"]\n        st.write(text)\n        time.sleep(4)\n    skip = st.button(\"Ignorer\")\n    if len(text) > 0 or skip:\n        add_grievances(key, supposed_state, text)\n        st.rerun()\n\nzdc = st.selectbox(\"Sélectionner gare\", get_all_zdc(), index=None)\n\nif zdc is None:\n    st.stop()\n\nif not (accessibility := get_accessibilite(zdc)).empty:\n    st.info(accessibility[\"accessibility_level_name\"].iloc[0].capitalize())\n\nzdc_formatted = (\n    zdc.replace(\" - \", \"_\")\n    .replace(\" \", \"_\")\n    .replace(\"é\", \"e\")\n    .replace(\"è\", \"e\")\n    .replace(\"-\", \"_\")\n    .lower()\n)\npath = Path(f\"static/img/{zdc_formatted}.png\")\nif path.exists():\n    st.image(str(path))\n\nfor type_of_equipment, d in get_list_of_equipements(zdc).items():\n    for key, values in d.items():\n        left, middle_left, middle_right, right = st.columns(\n            [0.3, 0.1, 0.3, 0.3], vertical_alignment=\"center\"\n        )\n\n        state = values.get(\"state\")\n\n        if type_of_equipment == \"elevators\":\n            left.write(str(values[\"liftsituation\"] or \"ascenseur inconnu\"))\n        elif type_of_equipment == \"escalators\":\n            left.write(str(values[\"etage\"] or \"escalator inconnu\"))\n\n        middle_left.image(f\"static/img/{type_of_equipment}.png\", width=50)\n\n        if state == AVAILABLE or state == UNCERTAIN_AVAILABLE:\n            message = \"signaler un problème\"\n            middle_right.image(\n                \"static/img/thumb-up.png\",\n                width=20,\n            )\n        elif state == UNAVAILABLE or state == UNCERTAIN_UNAVAILABLE:\n            message = \"l'équipement fonctionne\"\n            middle_right.image(\n                \"static/img/thumb-down.png\",\n                width=20,\n            )\n            middle_right.markdown(\" / \".join(values[\"reasons_grievances\"]))\n        else:\n            message = \"décrire le fonctionnement de l'équipement\"\n            middle_right.image(\n                \"static/img/question.png\",\n                width=20,\n            )\n\n        if right.button(message, key=key):\n            grieve(\n                key,\n                (\n                    AVAILABLE\n                    if state in [UNAVAILABLE, UNCERTAIN_UNAVAILABLE]\n                    else (\n                        UNAVAILABLE\n                        if state in [AVAILABLE, UNCERTAIN_AVAILABLE]\n                        else UNCERTAIN  # stays uncertain whatever the message\n                    )\n                ),\n            )","description":"Ce code utilise Streamlit pour créer une interface utilisateur permettant de signaler des problèmes d'accessibilité dans les gares, avec la possibilité de transcrire des doléances audio en texte.","reutilisabilite":"L'utilisation de Streamlit pour créer des interfaces interactives est hautement réutilisable pour d'autres applications nécessitant une interaction utilisateur simple et rapide.","specificites_fonctionnelles":"Facilite la collecte de signalements d'accessibilité en permettant aux utilisateurs de soumettre des doléances via texte ou audio.","value_index":0.0012099213551119178}
{"themes":"Création d\\'une interface utilisateur (IHM), Conception de prompts, ","id_pepite":7,"equipe":"equipe_08_maidfm","langage":"PYTHON","is_api_idfm":0,"is_api_autres":0,"is_appel_llm":0,"is_creation_ihm":1,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":1,"is_geocoding":0,"is_angular":0,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_08_maidfm/Hackathon_équipe8/config/prompts.py","code":"prompt_test = \" Réponds en Francais et en json : {input}\"","description":"Ce code définit un prompt pour interagir avec un modèle d'IA, spécifiant que la réponse doit être en français et au format JSON.","reutilisabilite":"Le prompt est réutilisable pour toute application nécessitant des interactions avec un modèle d'IA, en particulier pour obtenir des réponses structurées en JSON.","specificites_fonctionnelles":"Le prompt est conçu pour garantir que les réponses de l'IA sont en français et structurées, ce qui est essentiel pour des applications nécessitant une intégration facile des réponses de l'IA.","value_index":0.03508771929824561}
{"themes":"Création d\\'une interface utilisateur (IHM), Création d\\'une API, ","id_pepite":74,"equipe":"equipe_09_alterego - idfm_hackaton_2024-main","langage":"PYTHON","is_api_idfm":0,"is_api_autres":0,"is_appel_llm":0,"is_creation_ihm":1,"is_creation_api":1,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":0,"is_geocoding":0,"is_angular":0,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_09_alterego/idfm_hackaton_2024-main%20%-%20%idfm_hackaton_2024-main/backend/api-reading-conversations/main.py","code":"app = FastAPI()\n\norigins = [\n    \"http://localhost\",\n    \"http://localhost:8080\",\n    \"http://localhost:5173\",\n    \"http://10.244.1.53:5173\",\n    \"*\"\n]\n\napp.add_middleware(\n    CORSMiddleware,\n    allow_origins=origins,\n    allow_credentials=True,\n    allow_methods=[\"*\"],\n    allow_headers=[\"*\"],\n)\n\nwith open('../../frontend-angular/db.json', 'r') as file:\n    data = json.load(file)\n\nusers = data['users']\n\n@app.get(\"/summarize_user_data\", response_class=HTMLResponse)\nasync def summarize_user_data():\n    summary = {\n        \"total_users\": len(users),\n        \"total_preferences\": len(users),\n        \"user_names\": [user[\"name\"] for user in users]\n    }\n    html_content = f\"\"\"\n    <html>\n        <body>\n            <h1>Summary:</h1>\n            <pre>{json.dumps(summary, indent=4)}</pre>\n        </body>\n    </html>\n    \"\"\"\n    return html_content","description":"This code sets up a FastAPI application with CORS middleware and defines an endpoint to summarize user data from a JSON file. It returns an HTML response with the total number of users and their names.","reutilisabilite":"The code is modular and can be reused for setting up similar API endpoints that need to handle JSON data and return HTML responses. The CORS setup is also reusable for other FastAPI applications.","specificites_fonctionnelles":"The code provides a summary of user data, which is useful for applications that need to display user statistics or profiles.","value_index":0.002347417840375587}
{"themes":"Création d\\'une interface utilisateur (IHM), Traitement audio ou vocal, ","id_pepite":78,"equipe":"equipe_05_mobilia","langage":"JAVASCRIPT","is_api_idfm":0,"is_api_autres":0,"is_appel_llm":0,"is_creation_ihm":1,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":1,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":0,"is_geocoding":0,"is_angular":0,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_05_mobilia/MobilIA-main/app/public/audio-processor-worklet.js","code":"const MIN_INT16 = -0x8000;\nconst MAX_INT16 = 0x7fff;\n\nclass PCMAudioProcessor extends AudioWorkletProcessor {\n    constructor() {\n        super();\n    }\n\n    process(inputs, outputs, parameters) {\n        const input = inputs[0];\n        if (input.length > 0) {\n            const float32Buffer = input[0];\n            const int16Buffer = this.float32ToInt16(float32Buffer);\n            this.port.postMessage(int16Buffer);\n        }\n        return true;\n    }\n\n    float32ToInt16(float32Array) {\n        const int16Array = new Int16Array(float32Array.length);\n        for (let i = 0; i < float32Array.length; i++) {\n            let val = Math.floor(float32Array[i] * MAX_INT16);\n            val = Math.max(MIN_INT16, Math.min(MAX_INT16, val));\n            int16Array[i] = val;\n        }\n        return int16Array;\n    }\n}\n\nregisterProcessor(\"audio-processor-worklet\", PCMAudioProcessor);","description":"Ce code définit un processeur audio qui convertit des données audio en format float32 en format int16. Il traite les entrées audio et envoie les données converties via un port de message.","reutilisabilite":"Le code est précieux pour les applications nécessitant une conversion de format audio, notamment pour l'interopérabilité entre différents systèmes audio. Sa modularité permet une intégration facile dans d'autres projets.","specificites_fonctionnelles":"Le code répond à des besoins de conversion de format audio, essentiel pour le traitement et la transmission de données audio dans des formats compatibles.","value_index":0.002257336343115124}
{"themes":"Création d\\'une interface utilisateur (IHM), Traitement audio ou vocal, ","id_pepite":81,"equipe":"equipe_05_mobilia","langage":"JAVASCRIPT","is_api_idfm":0,"is_api_autres":0,"is_appel_llm":0,"is_creation_ihm":1,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":1,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":0,"is_geocoding":0,"is_angular":0,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_05_mobilia/MobilIA-main/app/public/audio-playback-worklet.js","code":"class AudioPlaybackWorklet extends AudioWorkletProcessor {\n    constructor() {\n        super();\n        this.port.onmessage = this.handleMessage.bind(this);\n        this.buffer = [];\n    }\n\n    handleMessage(event) {\n        if (event.data === null) {\n            this.buffer = [];\n            return;\n        }\n        this.buffer.push(...event.data);\n    }\n\n    process(inputs, outputs, parameters) {\n        const output = outputs[0];\n        const channel = output[0];\n\n        if (this.buffer.length > channel.length) {\n            const toProcess = this.buffer.slice(0, channel.length);\n            this.buffer = this.buffer.slice(channel.length);\n            channel.set(toProcess.map(v => v / 32768));\n        } else {\n            channel.set(this.buffer.map(v => v / 32768));\n            this.buffer = [];\n        }\n\n        return true;\n    }\n}\n\nregisterProcessor(\"audio-playback-worklet\", AudioPlaybackWorklet);","description":"Ce code définit un processeur audio pour la lecture de données audio. Il gère les messages entrants pour remplir un tampon de données audio et traite ces données pour les envoyer à un canal de sortie audio.","reutilisabilite":"Ce code est réutilisable pour toute application nécessitant un traitement audio en temps réel dans un contexte de travail audio Web. Il est modulaire et peut être intégré dans d'autres projets nécessitant une gestion de tampon audio.","specificites_fonctionnelles":"Le code répond à des besoins de traitement audio en temps réel, ce qui est crucial pour des applications interactives ou multimédia.","value_index":0.0021691973969631237}
{"themes":"Création d\\'une interface utilisateur (IHM), Utilisation d\\'Angular, ","id_pepite":111,"equipe":"equipe_09_alterego","langage":"JAVASCRIPT","is_api_idfm":0,"is_api_autres":0,"is_appel_llm":0,"is_creation_ihm":1,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":0,"is_geocoding":0,"is_angular":1,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_09_alterego/idfm_hackaton_2024-main/frontend-angular/src/app/components/directions/directions.component.ts","code":"import { Component, OnInit } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { FormsModule } from '@angular/forms';\n\n@Component({\n  selector: 'app-directions',\n  standalone: true,\n  imports: [CommonModule, FormsModule],\n  templateUrl: './directions.component.html',\n  styleUrls: ['./directions.component.css']\n})\nexport class DirectionsComponent implements OnInit {\n  inputNumber: number | null = null;\n  result: number | null = null;\n  loading: boolean = false;\n  conversationSummary: string = '';\n  userDataSummary: string = '';\n  optionsAndMetadata: string = '';\n  message: string = '';\n  intentionsEntities: string = '';\n\n  addTwo() {\n    if (this.inputNumber !== null) {\n      this.loading = true;\n      fetch(`http://localhost:8002/add_two/${this.inputNumber}`)\n        .then(response => response.json())\n        .then(data => {\n          this.result = data.result;\n          this.loading = false;\n        })\n        .catch(() => {\n          this.loading = false;\n          alert('Error fetching data');\n        });\n    }\n  }\n\n  fetchConversationSummary() {\n    fetch('http://localhost:8003/summarize_conversations')\n      .then(response => response.text())\n      .then(data => {\n        this.conversationSummary = data;\n      })\n      .catch(() => {\n        alert('Error fetching conversation summary');\n      });\n  }\n\n  fetchUserDataSummary() {\n    fetch('http://localhost:8003/summarize_user_data')\n      .then(response => response.text())\n      .then(data => {\n        this.userDataSummary = data;\n      })\n      .catch(() => {\n        alert('Error fetching user data summary');\n      });\n  }\n\n  fetchOptionsAndMetadata() {\n    fetch('http://localhost:8002/options_and_metadata')\n      .then(response => response.json())\n      .then(data => {\n        this.optionsAndMetadata = JSON.stringify(data, null, 2);\n      })\n      .catch(() => {\n        alert('Error fetching options and metadata');\n      });\n  }\n\n  fetchIntentionsEntities() {\n    if (this.message.trim() !== '') {\n      fetch('http://localhost:8001/get_intentions_entites', {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({ message: this.message })\n      })\n      .then(response => response.json())\n      .then(data => {\n        this.intentionsEntities = JSON.stringify(data, null, 2);\n      })\n      .catch(() => {\n        alert('Error fetching intentions and entities');\n      });\n    }\n  }\n\n  ngOnInit() {\n    this.fetchConversationSummary();\n    this.fetchUserDataSummary();\n    this.fetchOptionsAndMetadata();\n  }\n}","description":"Ce composant Angular gère plusieurs fonctionnalités, notamment l'ajout de deux à un nombre donné, la récupération de résumés de conversations et de données utilisateur, ainsi que l'obtention d'intentions et d'entités à partir d'un message. Il utilise des appels API pour interagir avec des services backend.","reutilisabilite":"Le code est modulaire et utilise des appels API pour des fonctionnalités spécifiques, ce qui le rend réutilisable dans d'autres projets nécessitant des interactions similaires avec des services backend.","specificites_fonctionnelles":"Le composant répond à des besoins fonctionnels tels que l'analyse de données utilisateur et de conversations, ainsi que l'interaction avec des services backend pour enrichir l'expérience utilisateur.","value_index":0.0007686395080707148}
{"themes":"Fonctionnalités de cartographie, ","id_pepite":121,"equipe":"equipe_10_ivoice","langage":"PYTHON","is_api_idfm":0,"is_api_autres":0,"is_appel_llm":0,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":1,"is_nlp":0,"is_websocket":0,"is_prompt_design":0,"is_geocoding":0,"is_angular":0,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_10_ivoice/ivoice-main/src/front_map.py","code":"import folium\n\ndef create_map(messages_dict):\n    paris = [48.8566, 2.3522]\n    carto = folium.Map(location=paris, zoom_start=12)\n    stations = [\n        \"Pont de Sèvres\", \"Billancourt\", \"Marcel Sembat\", \"Porte de Saint-Cloud\", \"Exelmans\", \"Michel-Ange - Molitor\",\n        \"Jasmin\", \"Ranelagh\", \"La Muette\", \"Rue de la Pompe\", \"Trocadéro\", \"Iéna\", \"Alma-Marceau\", \"Franklin D. Roosevelt\",\n        \"Saint-Philippe-du-Roule\", \"Miromesnil\", \"Saint-Augustin\", \"Havre - Caumartin\", \"Chaussée d'Antin - La Fayette\",\n        \"Richelieu - Drouot\", \"Grands Boulevards\", \"Bonne Nouvelle\", \"Strasbourg - Saint-Denis\", \"République\", \"Oberkampf\",\n        \"Saint-Ambroise\", \"Voltaire\", \"Charonne\", \"Rue des Boulets\", \"Nation\", \"Buzenval\", \"Maraîchers\", \"Porte de Montreuil\",\n        \"Robespierre\", \"Croix de Chavaux\", \"Mairie de Montreuil\"\n    ]\n    latitudes = [\n        48.823964, 48.835907, 48.836888, 48.839375, 48.841398, 48.844135, 48.848396, 48.856180, 48.860417, 48.865891,\n        48.863516, 48.865298, 48.863292, 48.869229, 48.872070, 48.876091, 48.874364, 48.874632, 48.874384, 48.871696,\n        48.870002, 48.869400, 48.867317, 48.866147, 48.863762, 48.861379, 48.857391, 48.852542, 48.847788, 48.849933,\n        48.850933, 48.850716, 48.853238, 48.861215, 48.871215\n    ]\n    longitudes = [\n        2.233380, 2.239462, 2.246494, 2.259622, 2.264682, 2.268228, 2.273601, 2.278307, 2.280910, 2.282769, 2.288353,\n        2.293115, 2.300285, 2.307716, 2.312528, 2.316154, 2.320072, 2.328104, 2.333535, 2.339269, 2.348722, 2.354295,\n        2.363048, 2.369687, 2.377587, 2.383494, 2.389027, 2.392810, 2.397401, 2.406544, 2.412216, 2.418861, 2.432307,\n        2.440926, 2.446745\n    ]\n    for station, lat, lon in zip(stations, latitudes, longitudes):\n        message_voyageur = messages_dict.get(station)\n        popup_content = f\"\"\"<div style=\"font-size:16px;\"><b style=\"color:blue; font-size:20px;\">{station}</b><br><span style=\"font-size:18px;\">{message_voyageur}</span></div>\"\"\"\n        folium.Marker([lat, lon], popup=folium.Popup(popup_content, max_width=400, min_width=200)).add_to(carto)\n    html_string = carto.get_root().render()\n    return html_string","description":"Ce code crée une carte interactive de Paris avec des marqueurs pour chaque station de métro spécifiée. Chaque marqueur affiche un message contextuel lorsqu'il est cliqué.","reutilisabilite":"Le code utilise la bibliothèque Folium pour créer des cartes interactives, ce qui est réutilisable pour toute application nécessitant une visualisation géographique des données.","specificites_fonctionnelles":"Le code répond au besoin de visualiser des informations de transport en commun sur une carte, ce qui est essentiel pour les applications de mobilité.","value_index":0.0004636068613815484}
{"themes":"Génération de données, ","id_pepite":8,"equipe":"equipe_10_ivoice","langage":"PYTHON","is_api_idfm":0,"is_api_autres":0,"is_appel_llm":0,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":0,"is_geocoding":0,"is_angular":0,"is_data_generation":1,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_10_ivoice/ivoice-main/src/front.py","code":"def itineraire_generation(): ...","description":"Génère des itinéraires alternatifs en utilisant l'ID de ligne spécifié.","reutilisabilite":"Peut être réutilisé pour calculer des itinéraires alternatifs pour différentes lignes, ce qui est crucial pour la planification de trajets.","specificites_fonctionnelles":"Permet de proposer des solutions de repli en cas de perturbation sur une ligne de transport.","value_index":0.03125}
{"themes":"Génération de données, ","id_pepite":26,"equipe":"equipe_10_ivoice","langage":"PYTHON","is_api_idfm":0,"is_api_autres":0,"is_appel_llm":0,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":0,"is_geocoding":0,"is_angular":0,"is_data_generation":1,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_10_ivoice/ivoice-main/src/front.py","code":"def message_generation(itineraries: dict[str, list[Itinerary]], infos_incident: str): ...","description":"Génère des messages basés sur les itinéraires et les informations d'incident fournies.","reutilisabilite":"La fonction est modulaire et peut être utilisée pour générer des messages pour différents types d'incidents et itinéraires.","specificites_fonctionnelles":"Facilite la communication des informations d'incident aux utilisateurs finaux.","value_index":0.011235955056179775}
{"themes":"Génération de données, ","id_pepite":30,"equipe":"equipe_08_maidfm - Hackathon-IDFM","langage":"PYTHON","is_api_idfm":0,"is_api_autres":0,"is_appel_llm":0,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":0,"is_geocoding":0,"is_angular":0,"is_data_generation":1,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_08_maidfm%20%-%20%Hackathon-IDFM/prompt_évènement.py","code":"def get_relevant_events(user_interests, df_events): ... def generate_custom_message(user_data, events): ...","description":"Ce fichier génère des messages personnalisés pour les utilisateurs en fonction de leurs centres d'intérêts et des événements disponibles en Île-de-France.","reutilisabilite":"Les fonctions de sélection d'événements pertinents et de génération de messages peuvent être réutilisées pour d'autres applications nécessitant une personnalisation basée sur les intérêts des utilisateurs.","specificites_fonctionnelles":"Le code permet de recommander des événements pertinents aux utilisateurs, enrichissant ainsi leur expérience culturelle et sociale.","value_index":0.009345794392523364}
{"themes":"Génération de données, ","id_pepite":50,"equipe":"equipe_08_maidfm - Hackathon-IDFM","langage":"PYTHON","is_api_idfm":0,"is_api_autres":0,"is_appel_llm":0,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":0,"is_geocoding":0,"is_angular":0,"is_data_generation":1,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_08_maidfm%20%-%20%Hackathon-IDFM/generation_base_userid.py","code":"def generate_trips(): ... def generate_ticket_info(): ... def generate_favorite_places(): ... def generate_interests(): ... def generate_km_walked(): ... def generate_pmr(): ... def generate_event_interest(): ...","description":"Ce fichier génère des données fictives pour des utilisateurs, incluant des trajets favoris, des informations de billettique, des lieux favoris, des centres d'intérêts, des kilomètres de marche, et des informations sur l'accessibilité PMR.","reutilisabilite":"Les fonctions de génération de données sont modulaires et peuvent être réutilisées pour simuler des données utilisateurs dans d'autres projets nécessitant des données de transport ou de billettique.","specificites_fonctionnelles":"Le code répond au besoin de simuler des données utilisateurs pour tester des fonctionnalités liées aux transports et à la billettique.","value_index":0.0047169811320754715}
{"themes":"Génération de données, ","id_pepite":63,"equipe":"equipe_07_tranquiliscore","langage":"PYTHON","is_api_idfm":0,"is_api_autres":0,"is_appel_llm":0,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":0,"is_geocoding":0,"is_angular":0,"is_data_generation":1,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_07_tranquiliscore/tranquili-score-main/pre-processing-creation-squelette-jddonness.py","code":"def datetime_range(start, end, delta):\n    current = start\n    while current < end:\n        yield current\n        current += delta\n\ndts = [dt.strftime('%Y-%m-%d %H:%M:%S') for dt in \n       datetime_range(datetime(2023, 11, 1, 6), datetime(2023, 11, 15, 23), \n       timedelta(minutes=5))]","description":"Cette fonction génère une liste de timestamps à intervalles réguliers de 5 minutes entre deux dates données.","reutilisabilite":"Utile pour générer des séries temporelles à intervalles réguliers, applicable dans divers contextes nécessitant des données temporelles.","specificites_fonctionnelles":"Génère des intervalles de temps réguliers pour structurer des données temporelles dans un jeu de données.","value_index":0.0034602076124567475}
{"themes":"Génération de données, ","id_pepite":103,"equipe":"equipe_09_alterego","langage":"PYTHON","is_api_idfm":0,"is_api_autres":0,"is_appel_llm":0,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":0,"is_geocoding":0,"is_angular":0,"is_data_generation":1,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_09_alterego/idfm_hackaton_2024-main/https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/blob/main/dump.py","code":"def print_directory_structure(start_path: str, exclusion_patterns: Set[str]) -> str:\n    def _generate_tree(dir_path: str, prefix: str = '') -> List[str]:\n        entries = os.listdir(dir_path)\n        entries = sorted(entries, key=lambda x: (not os.path.isdir(os.path.join(dir_path, x)), x.lower()))\n        tree = []\n        for i, entry in enumerate(entries):\n            rel_path = os.path.relpath(os.path.join(dir_path, entry), start_path)\n            if is_excluded(rel_path, exclusion_patterns):\n                continue\n            \n            if i == len(entries) - 1:\n                connector = '└── '\n                new_prefix = prefix + '    '\n            else:\n                connector = '├── '\n                new_prefix = prefix + '│   '\n            \n            full_path = os.path.join(dir_path, entry)\n            if os.path.isdir(full_path):\n                tree.append(f\"{prefix}{connector}{entry}/\")\n                tree.extend(_generate_tree(full_path, new_prefix))\n            else:\n                tree.append(f\"{prefix}{connector}{entry}\")\n        return tree\n\n    tree = ['/ '] + _generate_tree(start_path)\n    return '\\n'.join(tree)","description":"Cette fonction génère une représentation textuelle de la structure d'un répertoire, en excluant les chemins spécifiés.","reutilisabilite":"Utile pour visualiser la structure de répertoires dans divers contextes, notamment pour des outils de documentation ou d'analyse de projets.","specificites_fonctionnelles":"Facilite la visualisation de la structure de fichiers, ce qui est essentiel pour comprendre l'organisation d'un projet.","value_index":0.0008598452278589854}
{"themes":"Géocodage, ","id_pepite":4,"equipe":"equipe_05_mobilia","langage":"PYTHON","is_api_idfm":0,"is_api_autres":0,"is_appel_llm":0,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":0,"is_geocoding":1,"is_angular":0,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_05_mobilia/MobilIA-main/api/geocode.py","code":"class GeocodingAPI: ...","description":"Cette classe fournit des méthodes pour géocoder et géocoder inversement des adresses en utilisant l'API de data.gouv.fr.","reutilisabilite":"La classe est modulaire et peut être intégrée dans d'autres projets nécessitant des services de géocodage, facilitant la conversion entre adresses et coordonnées.","specificites_fonctionnelles":"Permet la conversion d'adresses en coordonnées et vice versa, essentiel pour les applications de navigation et de localisation.","value_index":0.043478260869565216}
{"themes":"Géocodage, ","id_pepite":94,"equipe":"equipe_05_mobilia","langage":"JAVASCRIPT","is_api_idfm":0,"is_api_autres":0,"is_appel_llm":0,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":0,"is_geocoding":1,"is_angular":0,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_05_mobilia/MobilIA-main/app/src/utils/geolocation.ts","code":"import { reverseGeocode } from '../api/geocoding';\n\nexport const getCurrentLocation = async (): Promise<{ address: string; latitude: number; longitude: number }> => {\n    try {\n        const position = await new Promise<GeolocationPosition>((resolve, reject) => {\n            navigator.geolocation.getCurrentPosition(resolve, reject);\n        });\n        const { latitude, longitude } = position.coords;\n        const address = await reverseGeocode(latitude, longitude);\n        return { address, latitude, longitude };\n    } catch (error) {\n        console.error('Erreur de géolocalisation:', error);\n        throw new Error('Impossible d\\'obtenir votre position actuelle');\n    }\n};","description":"Ce code utilise l'API de géolocalisation du navigateur pour obtenir la position actuelle de l'utilisateur, puis utilise une fonction de géocodage inversé pour obtenir l'adresse correspondante.","reutilisabilite":"Ce code est réutilisable pour toute application nécessitant la géolocalisation de l'utilisateur et la conversion de coordonnées en adresse. Il est modulaire et peut être intégré dans divers projets nécessitant des fonctionnalités de localisation.","specificites_fonctionnelles":"Permet de récupérer la position actuelle de l'utilisateur et de la convertir en une adresse lisible, ce qui est essentiel pour des applications de navigation ou de services basés sur la localisation.","value_index":0.0014619883040935672}
{"themes":"Intégration avec un Data Lake, ","id_pepite":21,"equipe":"equipe_10_ivoice","langage":"PYTHON","is_api_idfm":0,"is_api_autres":0,"is_appel_llm":0,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":1,"is_rag":0,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":0,"is_geocoding":0,"is_angular":0,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_10_ivoice/ivoice-main/src/dataloaders.py","code":"def load_parquet_from_s3(bucket: str, file_key: str) -> pd.DataFrame: ...","description":"Cette fonction charge un fichier Parquet depuis un bucket S3 spécifié et le retourne sous forme de DataFrame Pandas.","reutilisabilite":"La fonction est générique et peut être réutilisée pour charger n'importe quel fichier Parquet depuis S3, ce qui est utile pour la gestion de données volumineuses.","specificites_fonctionnelles":"Permet de centraliser et simplifier l'accès aux données stockées sur S3 pour le projet.","value_index":0.0136986301369863}
{"themes":"Intégration avec un Data Lake, ","id_pepite":44,"equipe":"equipe_02_elevate_us - accessibility-waze-main","langage":"PYTHON","is_api_idfm":0,"is_api_autres":0,"is_appel_llm":0,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":1,"is_rag":0,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":0,"is_geocoding":0,"is_angular":0,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_02_elevate_us/accessibility-waze-main%20%-%20%accessibility-waze-main/add_station_accessibility.py","code":"S3_ENDPOINT_URL = \"https://\" + os.environ[\"AWS_S3_ENDPOINT\"]\nfs = s3fs.S3FileSystem(client_kwargs={\"endpoint_url\": S3_ENDPOINT_URL})\nfs.ls(\"dlb-hackathon/datasets-diffusion\", refresh=True)","description":"Ce code initialise un système de fichiers S3 en utilisant un point de terminaison AWS personnalisé et liste les documents dans un répertoire S3 spécifique.","reutilisabilite":"Ce code est réutilisable pour toute application nécessitant l'accès à des fichiers stockés sur un système S3, en particulier dans des environnements où les variables d'environnement sont utilisées pour configurer les points de terminaison.","specificites_fonctionnelles":"Permet l'accès aux données partagées pour le hackathon, facilitant ainsi l'intégration et le traitement des données.","value_index":0.005319148936170213}
{"themes":"Intégration avec un Data Lake, Manipulation de données, ","id_pepite":53,"equipe":"equipe_02_elevate_us - accessibility-waze-main","langage":"PYTHON","is_api_idfm":0,"is_api_autres":0,"is_appel_llm":0,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":1,"is_rag":0,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":0,"is_geocoding":0,"is_angular":0,"is_data_generation":0,"is_data_manipulation":1,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_02_elevate_us/accessibility-waze-main%20%-%20%accessibility-waze-main/edit_grievances.py","code":"def add_grievances(equipment_id, state, commentaire):\n    category = categorize_signaling(commentaire)\n    df = pd.DataFrame(\n        data={\n            \"equipment_id\": equipment_id,\n            \"datetime\": datetime.now(),\n            \"state\": state,\n            \"commentaire\": commentaire,\n            \"category\": category,\n        },\n        index=[0],\n    )\n    with fs.open(FILE_PATH_OUT_S3, \"a\") as file_out:\n        df.to_csv(file_out, header=None)","description":"Cette fonction ajoute une réclamation concernant un équipement spécifique, en catégorisant le commentaire et en enregistrant les données dans un fichier CSV sur S3.","reutilisabilite":"La fonction est utile pour toute application nécessitant la gestion et le stockage de réclamations ou de feedbacks utilisateurs, avec une catégorisation automatique des commentaires.","specificites_fonctionnelles":"Permet de suivre et de catégoriser les réclamations sur les équipements, ce qui est essentiel pour la maintenance et l'amélioration des services.","value_index":0.004405286343612335}
{"themes":"Intégration avec un Data Lake, Manipulation de données, ","id_pepite":69,"equipe":"equipe_02_elevate_us","langage":"PYTHON","is_api_idfm":0,"is_api_autres":0,"is_appel_llm":0,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":1,"is_rag":0,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":0,"is_geocoding":0,"is_angular":0,"is_data_generation":0,"is_data_manipulation":1,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_02_elevate_us/accessibility-waze-main/handle_grievances.py","code":"import pandas as pd\nimport s3fs\nimport os\n\nS3_ENDPOINT_URL = \"https://\" + os.environ[\"AWS_S3_ENDPOINT\"]\nfs = s3fs.S3FileSystem(client_kwargs={'endpoint_url': S3_ENDPOINT_URL})\n\ndef update_grievances():\n    BUCKET = \"dlb-hackathon\"\n    FILE_KEY_S3 = \"equipe-2/grievances.csv\"\n    FILE_PATH_S3 = BUCKET + \"/\" + FILE_KEY_S3\n\n    with fs.open(FILE_PATH_S3, mode=\"r\") as file_in:\n        grievances = pd.read_csv(file_in)\n\n    grievances = grievances.groupby(\"equipement_id\").apply(handle_equipement)\n\n    with fs.open(FILE_PATH_S3, \"w\") as file_out:\n        grievances.to_csv(file_out)\n\ndef handle_equipement(single_grievances: pd.DataFrame) -> pd.DataFrame:\n    # delete useless data\n    pass","description":"Ce code lit un fichier CSV depuis un bucket S3, traite les données par groupe d'équipement, puis réécrit le fichier mis à jour dans le même emplacement S3.","reutilisabilite":"Le code est réutilisable pour toute opération de lecture/écriture de fichiers CSV sur S3, ce qui est courant dans les applications de traitement de données.","specificites_fonctionnelles":"Gère les doléances liées aux équipements en les regroupant par identifiant d'équipement.","value_index":0.002902757619738752}
{"themes":"Intégration avec un Data Lake, Manipulation de données, ","id_pepite":124,"equipe":"equipe_02_elevate_us","langage":"PYTHON","is_api_idfm":0,"is_api_autres":0,"is_appel_llm":0,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":1,"is_rag":0,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":0,"is_geocoding":0,"is_angular":0,"is_data_generation":0,"is_data_manipulation":1,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_02_elevate_us/accessibility-waze-main/accessibility-waze-main/add_state_to_equipements.py","code":"import os\nimport s3fs\nimport pandas as pd\nimport numpy as np\nfrom datetime import datetime\nfrom dateutil.relativedelta import relativedelta\nfrom signaling import CATEGORY_TO_EXPLANATION\n\nimport duckdb as ddb\n\nAVAILABLE = 0\nUNCERTAIN_AVAILABLE = 1\nUNCERTAIN = 2\nUNCERTAIN_UNAVAILABLE = 3\nUNAVAILABLE = 4\n\n\nS3_ENDPOINT_URL = \"https://\" + os.environ[\"AWS_S3_ENDPOINT\"]\nfs = s3fs.S3FileSystem(client_kwargs={\"endpoint_url\": S3_ENDPOINT_URL})\n\nddb.execute(\"SET s3_region='fr-central';\")\nddb.execute(\"SET s3_url_style='path';\")\nddb.execute(\"SET s3_endpoint='minio.data-platform-self-service.net';\")\nddb.execute(\n    f\"SET s3_access_key_id='{os.environ[\"AWS_ACCESS_KEY_ID\"]}' ;\"\n)  # Aussi récupérable dans les paramètres \"Valeurs de Helm\" du service\nddb.execute(\n    f\"SET s3_secret_access_key='{os.environ[\"AWS_SECRET_ACCESS_KEY\"]}';\"\n)  # Aussi récupérable dans les paramètres \"Valeurs de Helm\"\n\n\ndef get_history_state_of_equipement(equipment_id) -> datetime:\n    limit_date = (datetime.now() - relativedelta(month=6)).strftime(\"%Y-%m-%d %H:%M:%S\")\n\n    history_ascenseur = ddb.sql(\n        f\"\"\" \n        select * from 's3://dlb-hackathon/datasets-diffusion/ascenseurs_historique_etat/RELEVES_ETATS_ASCENSEURS_SNCF_RATP_2021-2024.parquet'\n        where code_appareil = {equipment_id}\n        and date_releve >= '{limit_date}'\n        \"\"\"\n    ).to_df()\n\n    return (\n        history_ascenseur[\n            history_ascenseur[\"etat\"] != history_ascenseur[\"etat\"].shift()\n        ]\n        .assign(\n            **{\n                \"datetime_delta\": lambda df: df[\"date_releve\"]\n                - df[\"date_releve\"].shift()\n            }\n        )\n        .loc[lambda df: df[\"etat\"] == \"1\"][\"datetime_delta\"]\n        .mean()\n    )\n\n\ndef get_state_from_grievances(equipements) -> pd.Series:\n    BUCKET = \"dlb-hackathon\"\n    FILE_KEY_S3 = \"equipe-2/grievances.csv\"\n    FILE_PATH_S3 = BUCKET + \"/\" + FILE_KEY_S3\n\n    with fs.open(FILE_PATH_S3, mode=\"r\") as file_in:\n        grievances = pd.read_csv(file_in, index_col=0).astype(\n            {\"equipment_id\": str, \"state\": int}\n        )\n\n    states = (\n        grievances[grievances[\"equipment_id\"].isin(equipements[\"id\"].astype(str))]\n        .sort_values(by=[\"equipment_id\", \"datetime\"])\n        .groupby(\"equipment_id\")\n        .apply(find_state_from_grievances_for_equipement)\n    )\n\n    return states\n\n\nCONFIDENCE_THRESHOLD = 10\nDATETIME_THRESHOLD = {AVAILABLE: np.inf, UNAVAILABLE: relativedelta(hours=24)}\nUNSURE_STATE = {AVAILABLE: UNCERTAIN_AVAILABLE, UNAVAILABLE: UNCERTAIN_UNAVAILABLE}\n\n\ndef find_state_from_grievances_for_equipement(grievances: pd.DataFrame) -> dict:\n    if grievances.empty:\n        return pd.Series({\"state\": UNCERTAIN, \"last_datetime\": pd.NaT, \"reasons\": []})\n\n    last_state = grievances.iloc[-1][\"state\"]\n    last_datetime = grievances.iloc[-1][\"datetime\"]\n    nb_identical = (grievances[\"state\"] == last_state).iloc[::-1].cumprod().sum()\n    reasons = (\n        grievances.iloc[-nb_identical:][\"category\"]\n        .map(CATEGORY_TO_EXPLANATION)\n        .fillna(\"Problème inconnu\")\n        .unique()\n        .tolist()\n    )\n\n    if (\n        nb_identical >= CONFIDENCE_THRESHOLD\n        and last_datetime >= DATETIME_THRESHOLD[last_state]\n    ):\n        return pd.Series(\n            {\"state\": last_state, \"last_datetime\": last_datetime, \"reasons\": reasons}\n        )\n    else:\n        return pd.Series(\n            {\n                \"state\": UNSURE_STATE.get(int(last_state), last_state),\n                \"last_datetime\": last_datetime,\n                \"reasons\": reasons,\n            }\n        )\n\n\ndef compute_state_for_elevators(elevators: pd.DataFrame) -> pd.DataFrame:\n    if elevators.empty:\n        return elevators.assign(\n            **{\n                \"state\": None,\n                \"reasons_grievances\": [],\n            }\n        )\n\n    states_from_grievances = get_state_from_grievances(\n        elevators.rename(columns={\"liftid\": \"id\"})\n    )\n\n    elevators[\"state\"] = elevators[\"liftstatus\"].map(\n        {\"available\": AVAILABLE, \"unknown\": UNCERTAIN, \"notavailable\": UNAVAILABLE}\n    )\n\n    if not states_from_grievances.empty:\n        elevators = elevators.merge(\n            states_from_grievances.add_suffix(\"_grievances\"),\n            left_on=\"liftid\",\n            right_index=True,\n            how=\"left\",\n        ).assign(\n            **{\n                \"state_grievances\": lambda df: df[\"state_grievances\"].fillna(\n                    df[\"state\"]\n                )\n            }\n        )\n\n        elevators.loc[elevators[\"state\"] == UNCERTAIN, \"state\"] = elevators[\n            \"state_grievances\"\n        ]\n        news_from_grievances = (\n            pd.to_datetime(elevators[\"liftstateupdate\"])\n            < elevators[\"last_datetime_grievances\"]\n        )\n        elevators.loc[~news_from_grievances, \"reasons_grievances\"] = \"\"\n        elevators.loc[\n            ~news_from_grievances & elevators[\"state\"] == UNAVAILABLE,\n            \"reasons_grievances\",\n        ] = CATEGORY_TO_EXPLANATION[\"Ascenseur-fonctionnement\"]\n\n        grievances_and_idfm_agree_available = (elevators[\"state\"] == AVAILABLE) & (\n            elevators[\"state_grievances\"].isin(\n                [AVAILABLE, UNCERTAIN_AVAILABLE, UNCERTAIN]\n            )\n        )\n        grievances_and_idfm_agree_unavailable = (elevators[\"state\"] == UNAVAILABLE) & (\n            elevators[\"state_grievances\"].isin(\n                [UNAVAILABLE, UNCERTAIN_UNAVAILABLE, UNCERTAIN]\n            )\n        )\n        elevators.loc[\n            news_from_grievances & grievances_and_idfm_agree_available, \"state\"\n        ] = AVAILABLE\n        elevators.loc[\n            news_from_grievances & grievances_and_idfm_agree_unavailable, \"state\"\n        ] = UNAVAILABLE\n\n        elevators.loc[\n            news_from_grievances\n            & (~grievances_and_idfm_agree_available)\n            & (~grievances_and_idfm_agree_unavailable),\n            \"state\",\n        ] = elevators.loc[\n            news_from_grievances\n            & (~grievances_and_idfm_agree_available)\n            & (~grievances_and_idfm_agree_unavailable)\n        ][\n            \"state_grievances\"\n        ]\n\n    return elevators\n\n\ndef compute_state_for_escaliers(escaliers: pd.DataFrame) -> pd.DataFrame:\n    return (\n        escaliers.astype({\"id_escalier\": str})\n        .merge(\n            get_state_from_grievances(escaliers.rename(columns={\"id_escalier\": \"id\"})),\n            how=\"left\",\n            right_index=True,\n            left_on=\"id_escalier\",\n        )\n        .assign(**{\"state\": lambda df: df[\"state\"].fillna(UNCERTAIN)})\n        .rename(columns={\"reasons\": \"reasons_grievances\"})\n    )","description":"Ce fichier Python contient des fonctions pour évaluer l'état des équipements tels que les ascenseurs et les escaliers en utilisant des données historiques et des réclamations. Il utilise DuckDB pour interroger des données stockées sur S3 et pandas pour le traitement des données.","reutilisabilite":"Le code est précieux pour son intégration avec DuckDB et S3, permettant de traiter efficacement de grandes quantités de données. Les fonctions sont modulaires et peuvent être réutilisées pour d'autres projets nécessitant une évaluation de l'état des équipements basés sur des données historiques et des réclamations.","specificites_fonctionnelles":"Le code répond au besoin de surveiller l'état des équipements de transport en commun, en particulier les ascenseurs et les escaliers, en utilisant des données historiques et des réclamations pour fournir une évaluation précise de leur disponibilité.","value_index":0.0003022517757291824}
{"themes":"Intégration avec un Data Lake, Utilisation de Retrieval-Augmented Generation (RAG), ","id_pepite":58,"equipe":"equipe_08_maidfm - Hackathon-IDFM-main","langage":"PYTHON","is_api_idfm":0,"is_api_autres":0,"is_appel_llm":0,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":1,"is_rag":1,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":0,"is_geocoding":0,"is_angular":0,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/resultats/repositories/equipe_08_maidfm/Hackathon-IDFM-main/notebooks/HIAM2024","code":"# Paramétrage pour un appel Duckdb\n%pip install duckdb\nimport duckdb as ddb\nddb.execute(\"SET s3_region='fr-central';\")\nddb.execute(\"SET s3_url_style='path';\")\nddb.execute(\"SET s3_endpoint='minio.data-platform-self-service.net';\")\nddb.execute(f\"SET s3_access_key_id='{os.environ[\"AWS_ACCESS_KEY_ID\"]}' ;\") # Aussi récupérable dans les paramètres \"Valeurs de Helm\" du service\nddb.execute(f\"SET s3_secret_access_key='{os.environ[\"AWS_SECRET_ACCESS_KEY\"]}';\") # Aussi récupérable dans les paramètres \"Valeurs de Helm\" du service","description":"Ce code configure l'accès à un stockage S3 en utilisant DuckDB pour exécuter des requêtes SQL sur des fichiers stockés dans un environnement cloud.","reutilisabilite":"La configuration de DuckDB pour accéder à un stockage S3 est hautement réutilisable pour tout projet nécessitant l'accès à des données stockées dans le cloud.","specificites_fonctionnelles":"Le code permet de configurer l'accès à des données stockées dans le cloud, facilitant ainsi l'analyse de données à grande échelle.","value_index":0.003816793893129771}
{"themes":"Machine Learning (ML), ","id_pepite":67,"equipe":"equipe_07_tranquiliscore","langage":"PYTHON","is_api_idfm":0,"is_api_autres":0,"is_appel_llm":0,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":0,"is_ml":1,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":0,"is_geocoding":0,"is_angular":0,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_07_tranquiliscore/tranquili-score-main/classifier.ipynb","code":"df_encoded = pd.get_dummies(df, columns=['Gare_A','Gare_B'], dtype=int)\n\ndf_encoded[\"Indice_troncon_AB\"] = df_encoded[\"Indice_troncon_AB\"].apply(class_from_indice)\ndf_encoded[\"Indice_gare_A\"] = df_encoded[\"Indice_gare_A\"].apply(class_from_indice)\ndf_encoded[\"Indice_gare_B\"] = df_encoded[\"Indice_gare_B\"].apply(class_from_indice)","description":"Ce code encode les colonnes 'Gare_A' et 'Gare_B' en variables indicatrices et applique la fonction de classification des indices sur les colonnes de score.","reutilisabilite":"L'encodage en variables indicatrices est une technique standard en machine learning, réutilisable pour préparer des données catégorielles pour des modèles.","specificites_fonctionnelles":"Prépare les données pour l'entraînement de modèles de machine learning en encodant les catégories et en classifiant les scores.","value_index":0.00303951367781155}
{"themes":"Manipulation de données, ","id_pepite":52,"equipe":"equipe_02_elevate_us - accessibility-waze-main","langage":"PYTHON","is_api_idfm":0,"is_api_autres":0,"is_appel_llm":0,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":0,"is_geocoding":0,"is_angular":0,"is_data_generation":0,"is_data_manipulation":1,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_02_elevate_us/accessibility-waze-main%20%-%20%accessibility-waze-main/back.py","code":"def get_all_stations() -> list[str]:\n    referential = pd.read_csv(\"static/arrets-lignes.csv\", sep=\";\")\n    referential = referential[referential[\"mode\"] == \"Metro\"]\n    return referential[\"stop_name\"].sort_values().unique()","description":"Cette fonction lit un fichier CSV contenant des arrêts de lignes et retourne une liste unique de noms de stations de métro.","reutilisabilite":"La fonction est réutilisable pour extraire et manipuler des données de stations de métro à partir de fichiers CSV, ce qui est utile pour des analyses de données ou des applications de transport.","specificites_fonctionnelles":"Répond au besoin de lister toutes les stations de métro pour des analyses ou des visualisations spécifiques au projet.","value_index":0.004464285714285714}
{"themes":"Traitement audio ou vocal, ","id_pepite":9,"equipe":"equipe_06_mob_ia","langage":"PYTHON","is_api_idfm":0,"is_api_autres":0,"is_appel_llm":0,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":1,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":0,"is_geocoding":0,"is_angular":0,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_06_mob_ia/hackathon_idfm_octo_2024-main/sources/converter/speech_to_text.py","code":"def recognize_speech() -> str: ...","description":"Cette fonction utilise la reconnaissance vocale pour convertir la parole en texte, en utilisant l'API de Google.","reutilisabilite":"La fonction est réutilisable pour toute application nécessitant une interface de commande vocale ou de transcription.","specificites_fonctionnelles":"Permet l'interaction vocale avec l'application, facilitant l'accessibilité et l'utilisation mains libres.","value_index":0.029411764705882353}
{"themes":"Traitement audio ou vocal, ","id_pepite":14,"equipe":"equipe_06_mob_ia","langage":"PYTHON","is_api_idfm":0,"is_api_autres":0,"is_appel_llm":0,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":1,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":0,"is_geocoding":0,"is_angular":0,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_06_mob_ia/hackathon_idfm_octo_2024-main/hackathon_idfm_octo_2024-main/streamlit.py","code":"import streamlit as st ... st.audio(audio, autoplay=True)","description":"Ce code utilise Streamlit pour créer une interface utilisateur permettant de rechercher des itinéraires avec Mob'IA. Il intègre la géolocalisation, la reconnaissance vocale, et la synthèse vocale.","reutilisabilite":"L'intégration de la géolocalisation et des services de conversion texte-parole et parole-texte est précieuse pour des applications interactives nécessitant une interface utilisateur simple et efficace.","specificites_fonctionnelles":"Le code répond au besoin de fournir une interface utilisateur interactive pour la recherche d'itinéraires, intégrant des fonctionnalités de géolocalisation et de traitement vocal.","value_index":0.017543859649122806}
{"themes":"Traitement audio ou vocal, ","id_pepite":15,"equipe":"equipe_05_mobilia","langage":"PYTHON","is_api_idfm":0,"is_api_autres":0,"is_appel_llm":0,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":1,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":0,"is_geocoding":0,"is_angular":0,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_05_mobilia/MobilIA-main/api/functions.py","code":"def text_to_speech(text, filename, audio_folder='audio'): ...","description":"Convertit du texte en parole et enregistre le résultat sous forme de fichier audio.","reutilisabilite":"Cette fonction est réutilisable dans des applications nécessitant des capacités de synthèse vocale, comme les assistants vocaux ou les applications d'accessibilité.","specificites_fonctionnelles":"Améliore l'accessibilité en permettant la conversion de texte en audio, utile pour les utilisateurs malvoyants.","value_index":0.01639344262295082}
{"themes":"Traitement audio ou vocal, ","id_pepite":16,"equipe":"equipe_05_mobilia","langage":"JAVASCRIPT","is_api_idfm":0,"is_api_autres":0,"is_appel_llm":0,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":1,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":0,"is_geocoding":0,"is_angular":0,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_05_mobilia/MobilIA-main/server/src/server/static/audio-processor-worklet.js","code":"class PCMAudioProcessor extends AudioWorkletProcessor { ... }","description":"Ce code définit une classe PCMAudioProcessor qui convertit des buffers audio de float32 à int16, puis envoie les données traitées via un port de message.","reutilisabilite":"La conversion de formats audio est une tâche courante dans le traitement audio numérique, rendant ce code utile pour d'autres projets nécessitant une telle conversion.","specificites_fonctionnelles":"Le code assure la conversion de données audio, ce qui est crucial pour l'interopérabilité entre différents systèmes audio.","value_index":0.01639344262295082}
{"themes":"Traitement audio ou vocal, ","id_pepite":18,"equipe":"equipe_05_mobilia","langage":"JAVASCRIPT","is_api_idfm":0,"is_api_autres":0,"is_appel_llm":0,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":1,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":0,"is_geocoding":0,"is_angular":0,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_05_mobilia/MobilIA-main/server/src/server/static/audio-playback-worklet.js","code":"class AudioPlaybackWorklet extends AudioWorkletProcessor { ... }","description":"Ce code définit une classe AudioPlaybackWorklet qui hérite de AudioWorkletProcessor. Elle gère la lecture audio en traitant les messages reçus et en ajustant le buffer audio pour la sortie.","reutilisabilite":"Ce code est réutilisable pour toute application nécessitant un traitement audio en temps réel dans un contexte de travail audio Web. Il offre une abstraction pour gérer les buffers audio.","specificites_fonctionnelles":"Le code répond au besoin de traitement audio en temps réel, essentiel pour des applications interactives ou multimédia.","value_index":0.015625}
{"themes":"Traitement audio ou vocal, ","id_pepite":28,"equipe":"equipe_09_alterego","langage":"JAVASCRIPT","is_api_idfm":0,"is_api_autres":0,"is_appel_llm":0,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":1,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":0,"is_geocoding":0,"is_angular":0,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_09_alterego/idfm_hackaton_2024-main/frontend-angular/src/app/models/recorded-audio-output.model.ts","code":"export interface RecordedAudioOutput {\n    blob: Blob;\n    duration: number;\n    title: string;\n  }","description":"Ce fichier définit une interface TypeScript pour représenter les données d'un enregistrement audio, incluant le blob audio, la durée et le titre.","reutilisabilite":"L'interface est réutilisable dans tout projet nécessitant une structure de données pour gérer des enregistrements audio. Elle fournit une abstraction claire pour manipuler les données audio.","specificites_fonctionnelles":"L'interface structure les données audio de manière standardisée, facilitant leur manipulation et leur intégration dans d'autres composants ou services.","value_index":0.010101010101010102}
{"themes":"Traitement audio ou vocal, ","id_pepite":41,"equipe":"equipe_09_alterego","langage":"JAVASCRIPT","is_api_idfm":0,"is_api_autres":0,"is_appel_llm":0,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":1,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":0,"is_geocoding":0,"is_angular":0,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_09_alterego/idfm_hackaton_2024-main/frontend-angular/src/app/components/chat/chat.component.ts","code":"@Component({\n  selector: 'app-chat',\n  imports: [VoiceRecorderComponent],\n  templateUrl: './chat.component.html',\n  styleUrl: './chat.component.css'\n})\nexport class ChatComponent {\n\n}","description":"Déclaration du composant ChatComponent, qui inclut un enregistreur vocal et utilise des fichiers de template et de style spécifiques.","reutilisabilite":"Le composant est modulaire et peut être réutilisé dans d'autres parties de l'application ou dans d'autres projets nécessitant une fonctionnalité de chat.","specificites_fonctionnelles":"Intègre un enregistreur vocal, ce qui peut être crucial pour des fonctionnalités de chat vocal ou d'interaction utilisateur.","value_index":0.00546448087431694}
{"themes":"Traitement audio ou vocal, ","id_pepite":48,"equipe":"equipe_06_mob_ia","langage":"PYTHON","is_api_idfm":0,"is_api_autres":0,"is_appel_llm":0,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":1,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":0,"is_geocoding":0,"is_angular":0,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_06_mob_ia/hackathon_idfm_octo_2024-main/sources/converter/text_to_speech.py","code":"from gtts import gTTS\nfrom io import BytesIO\n\ndef generate_audio(text: str) -> BytesIO:\n    sound_file = BytesIO()\n    tts = gTTS(text, lang='fr')\n    tts.write_to_fp(sound_file)\n\n    return sound_file","description":"Ce code utilise la bibliothèque gTTS pour convertir un texte en audio, en générant un fichier audio en mémoire.","reutilisabilite":"La fonction est réutilisable pour toute application nécessitant une conversion de texte en audio, notamment pour des fonctionnalités d'accessibilité ou des assistants vocaux.","specificites_fonctionnelles":"Répond à un besoin d'accessibilité en permettant la conversion de texte en audio.","value_index":0.004975124378109453}
{"themes":"Traitement audio ou vocal, ","id_pepite":73,"equipe":"equipe_09_alterego","langage":"JAVASCRIPT","is_api_idfm":0,"is_api_autres":0,"is_appel_llm":0,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":1,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":0,"is_geocoding":0,"is_angular":0,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_09_alterego/idfm_hackaton_2024-main/frontend-angular/src/app/services/audio-recorder.service.spec.ts","code":"import { TestBed } from '@angular/core/testing';\n\nimport { AudioRecorderService } from './audio-recorder.service';\n\ndescribe('AudioRecorderService', () => {\n  let service: AudioRecorderService;\n\n  beforeEach(() => {\n    TestBed.configureTestingModule({});\n    service = TestBed.inject(AudioRecorderService);\n  });\n\n  it('should be created', () => {\n    expect(service).toBeTruthy();\n  });\n});","description":"Ce fichier contient un test unitaire pour le service AudioRecorderService, vérifiant que le service est correctement créé.","reutilisabilite":"Le test est un exemple de test unitaire de base pour un service Angular, réutilisable comme modèle pour tester d'autres services dans des projets Angular.","specificites_fonctionnelles":"Le test assure que le service AudioRecorderService est instancié correctement, ce qui est essentiel pour garantir la fiabilité des fonctionnalités d'enregistrement audio.","value_index":0.002551020408163265}
{"themes":"Traitement audio ou vocal, ","id_pepite":123,"equipe":"equipe_05_mobilia - MobilIA","langage":"PYTHON","is_api_idfm":0,"is_api_autres":0,"is_appel_llm":0,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":1,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":0,"is_geocoding":0,"is_angular":0,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_05_mobilia/MobilIA-main%20%-%20%MobilIA/server/src/server/prompt.py","code":"INSTRUCTIONS = \"\"\"Tu es un assistant IA spécialisé dans la mobilité, capable de t'adapter aux besoins spécifiques de chaque utilisateur en fonction de ses handicaps. Voici comment tu dois te comporter :\n\n1. Analyse attentivement la liste des handicaps fournie pour chaque utilisateur.\n\n2. Si l'utilisateur a un handicap cognitif, utilise le langage FALC (Facile à Lire et à Comprendre) :\n   - Utilise des mots simples et des phrases courtes.\n   - Explique les idées complexes étape par étape.\n   - Évite les métaphores et le langage figuré.\n   - Sois direct et concret dans tes explications.\n\n3. Pour les handicaps physiques :\n   - Propose des solutions adaptées à leurs capacités motrices.\n   - Sois attentif aux besoins d'accessibilité spécifiques.\n\n4. Pour les handicaps sensoriels (vue, ouïe) :\n   - Adapte tes recommandations en conséquence.\n   - Suggère des alternatives ou des aides techniques appropriées.\n\n5. Reste patient, bienveillant et prêt à reformuler ou à donner plus de détails si nécessaire.\n\n6. Concentre-toi sur les capacités de l'utilisateur plutôt que sur ses limitations.\n\n7. Propose toujours des solutions sûres et pratiques pour améliorer la mobilité de l'utilisateur.\n\n8. Si l'utilisateur te demande d'analyser le contenu du bande son d'une annonce :\n    - Demande-lui de te faire écouter l'annonce.\n    - Analyse le contenu audio et indique ce qu'il contient, par exemple pour une personne sourde.\n\nAdapte ton langage et tes recommandations en fonction des handicaps spécifiques de chaque utilisateur pour offrir une assistance personnalisée et efficace.\n\nVoici la liste des handicaps possibles pour un utilisateur:\n- Cognitifs : déficience auditiva, déficience visuelle, déficience à la parole, déficience en raison de l'échec de la connaissance\n- Physiques : maladie cardiovasculaire, maladie respiratoire, maladie neurologique, handicap cérébral\n- Sensoriels : handicap auditif, handicap visuel\n\nL'utilisateur actuel a les handicap suivants :\n- Visuel : déficient visuel\n\nCommencez la conversation en demandant à l'utilisateur où il veut aller. \nC'est un échange vocal, donc soyez concis. Sois interactif, demande à l'utilisateur de choisir sans tout detailler par exemple.\n\nPARLE TOUJOURS EN FRANCAIS.\n\nATTENTION : POUR DONNER UNE DIRECTION TU DOIS UTILISER LES OUTILS DISPONIBLES ! ET SI BESOIN DEMANDER A UTILISATEUR DE PRECISER SA DEMANDE.\n\"\"\"","description":"Ce fichier contient les instructions pour un assistant IA spécialisé dans la mobilité, adapté aux besoins des utilisateurs avec différents types de handicaps.","reutilisabilite":"Les instructions sont réutilisables pour configurer des assistants IA dans des contextes similaires, en particulier pour des applications nécessitant une personnalisation en fonction des handicaps.","specificites_fonctionnelles":"Fournit des directives pour adapter les interactions de l'IA aux besoins spécifiques des utilisateurs handicapés, améliorant ainsi l'accessibilité et l'efficacité de l'assistance.","value_index":0.00042069835927639884}
{"themes":"Traitement audio ou vocal, ","id_pepite":125,"equipe":"equipe_05_mobilia","langage":"JAVASCRIPT","is_api_idfm":0,"is_api_autres":0,"is_appel_llm":0,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":1,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":0,"is_geocoding":0,"is_angular":0,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_05_mobilia/MobilIA-main/app/src/hooks/orientation.ts","code":"import { useState, useEffect } from 'react';\n\nconst useNavigation = () => {\n    const [currentStep, setCurrentStep] = useState(0);\n    const [route, setRoute] = useState([]);\n    const [currentLocation, setCurrentLocation] = useState(null);\n    const [deviceOrientation, setDeviceOrientation] = useState(null);\n\n    useEffect(() => {\n        fetchRouteData();\n        requestLocationPermission();\n        startLocationTracking();\n        startOrientationTracking();\n\n        return () => {\n            navigator.geolocation.clearWatch(watchId);\n            window.removeEventListener('deviceorientation', handleDeviceOrientation);\n        };\n    }, []);\n\n    const fetchRouteData = async () => {\n        // Fetch route data logic\n    };\n\n    const requestLocationPermission = async () => {\n        if ('geolocation' in navigator) {\n            const permission = await navigator.permissions.query({ name: 'geolocation' });\n            if (permission.state !== 'granted') {\n                alert('Location permission is required for navigation.');\n            }\n        } else {\n            alert('Geolocation is not supported by your browser.');\n        }\n    };\n\n    let watchId: any;\n    const startLocationTracking = () => {\n        watchId = navigator.geolocation.watchPosition(\n            (position) => {\n                setCurrentLocation(position.coords);\n                checkNextStep(position.coords);\n            },\n            (error) => {\n                console.error('Error getting location:', error);\n            },\n            { enableHighAccuracy: true, timeout: 5000, maximumAge: 0 }\n        );\n    };\n\n    const startOrientationTracking = () => {\n        window.addEventListener('deviceorientation', handleDeviceOrientation);\n    };\n\n    const handleDeviceOrientation = (event) => {\n        const { alpha, beta, gamma } = event;\n        setDeviceOrientation({ alpha, beta, gamma });\n    };\n\n    const checkNextStep = (coords) => {\n        if (currentStep < route.length) {\n            const nextPoint = route[currentStep].geopoint;\n            const distance = calculateDistance(coords, nextPoint);\n            const direction = calculateDirection(coords, nextPoint);\n\n            if (distance < 10) {\n                handleNextStep();\n            } else {\n                provideDirectionalGuidance(direction);\n            }\n        }\n    };\n\n    const calculateDistance = (point1, point2) => {\n        // Haversine formula to calculate distance between two points\n    };\n\n    const calculateDirection = (from, to) => {\n        const dx = to.longitude - from.longitude;\n        const dy = to.latitude - from.latitude;\n        let angle = Math.atan2(dy, dx) * 180 / Math.PI;\n        if (angle < 0) {\n            angle += 360;\n        }\n        return angle;\n    };\n\n    const provideDirectionalGuidance = (targetDirection) => {\n        if (deviceOrientation) {\n            const { beta, gamma } = deviceOrientation;\n            const deviceHeading = Math.atan2(beta, gamma) * 180 / Math.PI;\n\n            const relativeDirection = (targetDirection - deviceHeading + 360) % 360;\n\n            let guidance;\n            if (relativeDirection > 345 || relativeDirection <= 15) {\n                guidance = \"Straight ahead\";\n            } else if (relativeDirection > 15 && relativeDirection <= 75) {\n                guidance = \"Turn slight right\";\n            } else if (relativeDirection > 75 && relativeDirection <= 105) {\n                guidance = \"Turn right\";\n            } else if (relativeDirection > 105 && relativeDirection <= 165) {\n                guidance = \"Turn sharp right\";\n            } else if (relativeDirection > 165 && relativeDirection <= 195) {\n                guidance = \"Turn around\";\n            } else if (relativeDirection > 195 && relativeDirection <= 255) {\n                guidance = \"Turn sharp left\";\n            } else if (relativeDirection > 255 && relativeDirection <= 285) {\n                guidance = \"Turn left\";\n            } else {\n                guidance = \"Turn slight left\";\n            }\n\n            if ('speechSynthesis' in window) {\n                const utterance = new SpeechSynthesisUtterance(guidance);\n                window.speechSynthesis.speak(utterance);\n            } else {\n                console.log('Speech synthesis not supported');\n            }\n        }\n    };\n\n    const handleNextStep = () => {\n        // Logic to handle moving to the next step\n    };\n\n    return {\n        currentStep,\n        route,\n        currentLocation,\n        deviceOrientation,\n        setRoute,\n        handleNextStep,\n    };\n};\n\nexport default useNavigation;","description":"Ce hook React gère la navigation en temps réel en utilisant la géolocalisation et l'orientation de l'appareil pour guider l'utilisateur le long d'un itinéraire prédéfini. Il utilise des API de géolocalisation pour suivre la position de l'utilisateur et des événements d'orientation pour ajuster les instructions de navigation.","reutilisabilite":"Le hook est modulaire et peut être réutilisé dans d'autres projets nécessitant une navigation en temps réel. Il intègre des API natives pour la géolocalisation et l'orientation, ce qui le rend adaptable à divers cas d'utilisation de navigation.","specificites_fonctionnelles":"Fournit des instructions de navigation basées sur la position actuelle et l'orientation de l'appareil, avec des retours vocaux pour améliorer l'accessibilité.","value_index":0.00021635655560363478}
{"themes":"Traitement audio ou vocal, Utilisation d\\'Angular, ","id_pepite":66,"equipe":"equipe_09_alterego","langage":"JAVASCRIPT","is_api_idfm":0,"is_api_autres":0,"is_appel_llm":0,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":1,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":0,"is_geocoding":0,"is_angular":1,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_09_alterego/idfm_hackaton_2024-main/frontend-angular/src/app/components/voice-recorder/voice-recorder.component.spec.ts","code":"import { ComponentFixture, TestBed } from '@angular/core/testing';\n\nimport { VoiceRecorderComponent } from './voice-recorder.component';\n\ndescribe('VoiceRecorderComponent', () => {\n  let component: VoiceRecorderComponent;\n  let fixture: ComponentFixture<VoiceRecorderComponent>;\n\n  beforeEach(async () => {\n    await TestBed.configureTestingModule({\n      imports: [VoiceRecorderComponent]\n    })\n    .compileComponents();\n\n    fixture = TestBed.createComponent(VoiceRecorderComponent);\n    component = fixture.componentInstance;\n    fixture.detectChanges();\n  });\n\n  it('should create', () => {\n    expect(component).toBeTruthy();\n  });\n});","description":"Ce code est un test unitaire pour le composant Angular VoiceRecorderComponent. Il vérifie que le composant peut être créé sans erreur.","reutilisabilite":"Les tests unitaires sont essentiels pour garantir la stabilité et la fiabilité du code. Ce modèle de test peut être réutilisé pour tester d'autres composants Angular.","specificites_fonctionnelles":"Assure la création correcte du composant VoiceRecorder, ce qui est crucial pour le bon fonctionnement de l'application.","value_index":0.0031201248049922}
{"themes":"Traitement audio ou vocal, Utilisation d\\'Angular, ","id_pepite":98,"equipe":"equipe_09_alterego","langage":"JAVASCRIPT","is_api_idfm":0,"is_api_autres":0,"is_appel_llm":0,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":1,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":0,"is_geocoding":0,"is_angular":1,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_09_alterego/idfm_hackaton_2024-main/frontend-angular/src/app/components/voice-recorder/voice-recorder.component.ts","code":"import { Component } from '@angular/core';\nimport { AudioRecorderService } from '../../services/audio-recorder.service';\nimport { DomSanitizer, SafeUrl } from '@angular/platform-browser';\nimport { RecordedAudioOutput } from '../../models/recorded-audio-output.model';\nimport { blob } from 'stream/consumers';\n\n@Component({\n  selector: 'app-voice-recorder',\n  imports: [],\n  templateUrl: './voice-recorder.component.html',\n  styleUrl: './voice-recorder.component.css'\n})\nexport class VoiceRecorderComponent {\n  isRecording = false;\n  recordedTime = '00:00';\n  blobUrl!: SafeUrl;\n  recordedAudio!: RecordedAudioOutput;\n\n  constructor(private audioRecordingService: AudioRecorderService,\nprivate sanitizer: DomSanitizer) { \n  this.audioRecordingService.getRecordingFailed().subscribe(() => {\n    this.isRecording = false;\n  });\n\n}\n\n  startRecording() {\n    this.isRecording = true;\n    this.audioRecordingService.startRecording();\n    this.audioRecordingService.getRecordedTime().subscribe((time) => {\n      this.recordedTime = time;\n    });\n  }\n\n  stopRecording() {\n    this.isRecording = false;\n    this.audioRecordingService.stopRecording();\n    this.audioRecordingService.getRecorded().subscribe(event => {\n      this.recordedAudio = event;\n    });\n    this.blobUrl = this.sanitizer.bypassSecurityTrustUrl(URL.createObjectURL(this.recordedAudio.blob));\n  }\n\n  clearRecording() {\n    this.blobUrl = ''; \n    this.recordedTime = '00:00';\n    this.isRecording = false;\n  }\n\n  downloadRecording() {\n    const url = window.URL.createObjectURL(this.recordedAudio.blob);\n    const link =document.createElement('a');\n    link.href = url;\n    link.download = this.recordedAudio.title + '.webm';\n    link.click();\n  }\n\n}","description":"Ce composant Angular gère l'enregistrement audio, y compris le démarrage, l'arrêt, l'effacement et le téléchargement de l'enregistrement. Il utilise un service pour gérer la logique d'enregistrement et un sanitizer pour sécuriser les URL des blobs audio.","reutilisabilite":"Le composant est modulaire et peut être réutilisé dans d'autres projets nécessitant une fonctionnalité d'enregistrement audio. Il encapsule la logique d'enregistrement et d'interaction avec le DOM de manière propre.","specificites_fonctionnelles":"Le composant répond au besoin de capturer et de gérer des enregistrements audio dans une application web, ce qui peut être utile pour des fonctionnalités de reconnaissance vocale ou de messagerie vocale.","value_index":0.0011689070718877848}
{"themes":"Traitement d\\'images, ","id_pepite":20,"equipe":"equipe_05_mobilia","langage":"PYTHON","is_api_idfm":0,"is_api_autres":0,"is_appel_llm":0,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":0,"is_image":1,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":0,"is_geocoding":0,"is_angular":0,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_05_mobilia/MobilIA-main/api/functions.py","code":"def analyze_and_translate_image(image_path, target_language=\"en\"): ...","description":"Analyse une image pour en extraire une description, puis traduit cette description dans une langue cible en utilisant l'API OpenAI.","reutilisabilite":"Cette fonction est précieuse pour les applications nécessitant une traduction automatique de descriptions d'images, facilitant l'internationalisation.","specificites_fonctionnelles":"Facilite la traduction et la compréhension de descriptions d'images, ce qui est essentiel pour les utilisateurs multilingues.","value_index":0.014285714285714285}
{"themes":"Traitement d\\'images, Conception de prompts, ","id_pepite":11,"equipe":"equipe_05_mobilia","langage":"PYTHON","is_api_idfm":0,"is_api_autres":0,"is_appel_llm":0,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":0,"is_image":1,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":1,"is_geocoding":0,"is_angular":0,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_05_mobilia/MobilIA-main/server/src/server/tools.py","code":"@tool\nasync def analyze_image(image_url: str, prompt: Optional[str] = None):\n    ...","description":"Analyse une image en utilisant GPT-4 Vision et retourne une description.","reutilisabilite":"Cette fonction est réutilisable pour toute application nécessitant une analyse d'image automatisée, en intégrant GPT-4 Vision pour l'analyse de contenu visuel.","specificites_fonctionnelles":"Permet l'analyse d'images pour extraire des informations textuelles ou contextuelles, utile dans des applications de reconnaissance d'image.","value_index":0.023809523809523808}
{"themes":"Traitement du langage naturel (NLP), ","id_pepite":33,"equipe":"equipe_09_alterego - idfm_hackaton_2024","langage":"PYTHON","is_api_idfm":0,"is_api_autres":0,"is_appel_llm":0,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":1,"is_websocket":0,"is_prompt_design":0,"is_geocoding":0,"is_angular":0,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_09_alterego/idfm_hackaton_2024-main%20%-%20%idfm_hackaton_2024/backend/api-llm/src/test-llm.ipynb","code":"from nlu import Nlu\n\nnlu = Nlu()\nmessage = \"Donne moi l'itinéraire entre Poissy et Puteaux\"\nanswer = nlu.get_intentions_entites(message)\n\nanswer","description":"Ce code utilise un module NLU pour analyser un message et extraire les intentions et entités. Il est utilisé pour comprendre les requêtes utilisateur concernant les itinéraires.","reutilisabilite":"Le code est réutilisable pour toute application nécessitant une compréhension du langage naturel pour extraire des intentions et des entités, ce qui est crucial pour les systèmes de dialogue et les assistants virtuels.","specificites_fonctionnelles":"Le code répond au besoin de comprendre les requêtes utilisateur en langage naturel pour fournir des informations sur les itinéraires.","value_index":0.006944444444444444}
{"themes":"Traitement du langage naturel (NLP), ","id_pepite":75,"equipe":"equipe_09_alterego","langage":"PYTHON","is_api_idfm":0,"is_api_autres":0,"is_appel_llm":0,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":1,"is_websocket":0,"is_prompt_design":0,"is_geocoding":0,"is_angular":0,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_09_alterego/idfm_hackaton_2024-main/https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/blob/main/backend/api-llm/src/chat.py","code":"class Chatbot:\n    def __init__(self, history):\n        self.client = Client()\n        self.client = self.client.get_client()\n        self.model = 'gpt-4o-mini'\n\n    def ask_gpt(self, conversation_history, message):\n        nlu = Nlu()\n        intention = nlu.get_intentions_entites(message)\n        if (intention == \"RELATED_IDFM\"){\n            retrun \"Comment je peux vous aider\"\n        }\n        else{\n            retrun \"\"","description":"Cette classe implémente un chatbot utilisant un modèle de langage GPT pour répondre aux messages en fonction de l'intention détectée.","reutilisabilite":"La structure de la classe et l'utilisation de modèles GPT la rendent réutilisable pour divers cas d'utilisation de chatbots nécessitant une compréhension du langage naturel.","specificites_fonctionnelles":"Répond aux besoins de communication automatisée avec les utilisateurs, en intégrant des capacités de compréhension du langage naturel.","value_index":0.00234192037470726}
{"themes":"Utilisation d\\'Angular, ","id_pepite":54,"equipe":"equipe_09_alterego","langage":"JAVASCRIPT","is_api_idfm":0,"is_api_autres":0,"is_appel_llm":0,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":0,"is_geocoding":0,"is_angular":1,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_09_alterego/idfm_hackaton_2024-main/frontend-angular/src/app/components/preferences/preferences.component.ts","code":"import { Component } from '@angular/core';\n\n@Component({\n  selector: 'app-preferences',\n  imports: [],\n  templateUrl: './preferences.component.html',\n  styleUrl: './preferences.component.css'\n})\nexport class PreferencesComponent {\n\n}","description":"Déclaration du composant Angular PreferencesComponent, qui gère les préférences utilisateur dans l'application.","reutilisabilite":"Ce composant est réutilisable dans toute application Angular nécessitant une gestion des préférences utilisateur.","specificites_fonctionnelles":"Fournit une structure de base pour la gestion des préférences utilisateur dans l'application.","value_index":0.004291845493562232}
{"themes":"Utilisation d\\'Angular, ","id_pepite":70,"equipe":"equipe_09_alterego","langage":"JAVASCRIPT","is_api_idfm":0,"is_api_autres":0,"is_appel_llm":0,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":0,"is_geocoding":0,"is_angular":1,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_09_alterego/idfm_hackaton_2024-main/frontend-angular/src/app/app.config.server.ts","code":"import { mergeApplicationConfig, ApplicationConfig } from '@angular/core';\nimport { provideServerRendering } from '@angular/platform-server';\nimport { appConfig } from './app.config';\n\nconst serverConfig: ApplicationConfig = {\n  providers: [\n    provideServerRendering(),\n  ]\n};\n\nexport const config = mergeApplicationConfig(appConfig, serverConfig);","description":"Ce code configure le rendu côté serveur pour une application Angular en fusionnant la configuration de l'application avec des paramètres spécifiques au serveur.","reutilisabilite":"La fusion de configurations pour le rendu côté serveur est une pratique réutilisable dans les applications Angular nécessitant un rendu universel, ce qui est courant pour améliorer le SEO et les performances.","specificites_fonctionnelles":"Le code répond au besoin de rendre l'application Angular côté serveur, ce qui est crucial pour les applications nécessitant un rendu universel.","value_index":0.002857142857142857}
{"themes":"Utilisation d\\'Angular, ","id_pepite":71,"equipe":"equipe_09_alterego","langage":"JAVASCRIPT","is_api_idfm":0,"is_api_autres":0,"is_appel_llm":0,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":0,"is_geocoding":0,"is_angular":1,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_09_alterego/idfm_hackaton_2024-main/frontend-angular/src/app/app.routes.ts","code":"export const routes: Routes = [\n  {\n    path: '',\n    component: LandingComponent,\n    title: 'Landing',\n  }, {\n    path: 'preferences',\n    component: PreferencesComponent,\n    title: 'Preferences',\n  },\n  {\n    path: 'chat',\n    component: ChatComponent,\n    title: 'Chat',\n  },\n  {\n    path: 'directions',\n    component: DirectionsComponent,\n    title: 'Directions',\n  }\n];","description":"Ce code définit les routes pour une application Angular, associant des chemins d'URL à des composants spécifiques.","reutilisabilite":"La configuration des routes est un aspect fondamental et réutilisable dans toute application Angular, facilitant la navigation et la gestion des vues.","specificites_fonctionnelles":"Permet la navigation entre différentes sections de l'application, telles que les préférences, le chat, et les directions.","value_index":0.0026595744680851063}
{"themes":"Utilisation d\\'Angular, ","id_pepite":76,"equipe":"equipe_09_alterego","langage":"JAVASCRIPT","is_api_idfm":0,"is_api_autres":0,"is_appel_llm":0,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":0,"is_geocoding":0,"is_angular":1,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_09_alterego/idfm_hackaton_2024-main/frontend-angular/src/app/app.config.ts","code":"import { ApplicationConfig, provideZoneChangeDetection } from '@angular/core';\nimport { provideRouter } from '@angular/router';\n\nimport { routes } from './app.routes';\nimport { provideClientHydration, withEventReplay } from '@angular/platform-browser';\n\nexport const appConfig: ApplicationConfig = {\n  providers: [provideZoneChangeDetection({ eventCoalescing: true }), provideRouter(routes), provideClientHydration(withEventReplay())]\n};","description":"Ce code configure l'application Angular pour le client, en définissant des fournisseurs pour la détection des changements de zone, le routage, et l'hydratation du client avec relecture d'événements.","reutilisabilite":"La configuration modulaire et l'utilisation de fournisseurs pour des fonctionnalités spécifiques comme le routage et l'hydratation sont des pratiques réutilisables dans de nombreuses applications Angular.","specificites_fonctionnelles":"Le code assure une configuration client robuste pour l'application Angular, en intégrant des fonctionnalités essentielles comme le routage et l'hydratation.","value_index":0.002288329519450801}
{"themes":"Utilisation d\\'Angular, ","id_pepite":92,"equipe":"equipe_09_alterego","langage":"JAVASCRIPT","is_api_idfm":0,"is_api_autres":0,"is_appel_llm":0,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":0,"is_geocoding":0,"is_angular":1,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_09_alterego/idfm_hackaton_2024-main/frontend-angular/src/app/components/preferences/preferences.component.spec.ts","code":"import { ComponentFixture, TestBed } from '@angular/core/testing';\n\nimport { PreferencesComponent } from './preferences.component';\n\ndescribe('PreferencesComponent', () => {\n  let component: PreferencesComponent;\n  let fixture: ComponentFixture<PreferencesComponent>;\n\n  beforeEach(async () => {\n    await TestBed.configureTestingModule({\n      imports: [PreferencesComponent]\n    })\n    .compileComponents();\n\n    fixture = TestBed.createComponent(PreferencesComponent);\n    component = fixture.componentInstance;\n    fixture.detectChanges();\n  });\n\n  it('should create', () => {\n    expect(component).toBeTruthy();\n  });\n});","description":"Ce code est un test unitaire pour le composant Angular PreferencesComponent. Il vérifie que le composant peut être créé sans erreur.","reutilisabilite":"Les tests unitaires sont essentiels pour garantir la stabilité et la fiabilité du code. Ce modèle de test peut être réutilisé pour tester d'autres composants Angular.","specificites_fonctionnelles":"Assure la création correcte du composant Preferences, ce qui est crucial pour le bon fonctionnement de l'application.","value_index":0.001597444089456869}
{"themes":"Utilisation d\\'Angular, ","id_pepite":110,"equipe":"equipe_09_alterego","langage":"JAVASCRIPT","is_api_idfm":0,"is_api_autres":0,"is_appel_llm":0,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":0,"is_geocoding":0,"is_angular":1,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_09_alterego/idfm_hackaton_2024-main/frontend-angular/src/server.ts","code":"import { APP_BASE_HREF } from '@angular/common';\nimport { CommonEngine, isMainModule } from '@angular/ssr/node';\nimport express from 'express';\nimport { dirname, join, resolve } from 'node:path';\nimport { fileURLToPath } from 'node:url';\nimport bootstrap from './main.server';\n\nconst serverDistFolder = dirname(fileURLToPath(import.meta.url));\nconst browserDistFolder = resolve(serverDistFolder, '../browser');\nconst indexHtml = join(serverDistFolder, 'index.server.html');\n\nconst app = express();\nconst commonEngine = new CommonEngine();\n\napp.get(\n  '**',\n  express.static(browserDistFolder, {\n    maxAge: '1y',\n    index: 'index.html'\n  }),\n);\n\napp.get('**', (req, res, next) => {\n  const { protocol, originalUrl, baseUrl, headers } = req;\n\n  commonEngine\n    .render({\n      bootstrap,\n      documentFilePath: indexHtml,\n      url: `${protocol}://${headers.host}${originalUrl}`,\n      publicPath: browserDistFolder,\n      providers: [{ provide: APP_BASE_HREF, useValue: baseUrl }],\n    })\n    .then((html) => res.send(html))\n    .catch((err) => next(err));\n});\n\nif (isMainModule(import.meta.url)) {\n  const port = process.env['PORT'] || 4000;\n  app.listen(port, () => {\n    console.log(`Node Express server listening on http://localhost:${port}`);\n  });\n}","description":"Ce code configure un serveur Express pour servir une application Angular côté serveur. Il utilise Angular Universal pour le rendu côté serveur et sert des fichiers statiques depuis un dossier spécifique.","reutilisabilite":"Le code est réutilisable pour toute application Angular nécessitant un rendu côté serveur avec Express. Il offre une structure modulaire pour servir des applications Angular universelles.","specificites_fonctionnelles":"Le code répond au besoin de servir une application Angular avec rendu côté serveur, ce qui est essentiel pour le SEO et les performances initiales de chargement.","value_index":0.000794912559618442}
{"themes":"Utilisation d\\'autres API, Géocodage, ","id_pepite":83,"equipe":"equipe_05_mobilia - MobilIA","langage":"PYTHON","is_api_idfm":0,"is_api_autres":1,"is_appel_llm":0,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":0,"is_geocoding":1,"is_angular":0,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_05_mobilia/MobilIA-main%20%-%20%MobilIA/server/src/server/geocode.py","code":"class GeocodingAPI:\n    def __init__(self):\n        self.base_url = \"https://api-adresse.data.gouv.fr\"\n\n    async def geocode(self, address: str) -> list:\n        try:\n            response = requests.get(f\"{self.base_url}/search/\", params={\n                \"q\": address,\n                \"limit\": 10,\n                \"lat\": 48.8566,\n                \"lon\": 2.3522\n            })\n            response.raise_for_status()\n            data = response.json()\n\n            if data[\"features\"]:\n                results = []\n                for feature in data[\"features\"]:\n                    lon, lat = feature[\"geometry\"][\"coordinates\"]\n                    results.append({\n                        \"lat\": lat,\n                        \"lon\": lon,\n                        \"label\": feature[\"properties\"][\"label\"]\n                    })\n                return results\n            else:\n                raise ValueError(\"No coordinates found for the given address\")\n        except requests.RequestException as error:\n            print(f\"Error in geocoding: {error}\")\n            raise","description":"Cette classe et méthode permettent de géocoder une adresse en utilisant l'API de géocodage du gouvernement français. Elle retourne une liste de suggestions de coordonnées géographiques.","reutilisabilite":"Le code est réutilisable pour toute application nécessitant une conversion d'adresses en coordonnées géographiques. Il est basé sur une API publique et gère les erreurs de requête.","specificites_fonctionnelles":"Fournit des suggestions de géocodage précises pour des adresses en France, centrées sur Paris.","value_index":0.0018656716417910447}
{"themes":"Utilisation d\\'autres API, Géocodage, ","id_pepite":113,"equipe":"equipe_05_mobilia","langage":"JAVASCRIPT","is_api_idfm":0,"is_api_autres":1,"is_appel_llm":0,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":0,"is_geocoding":1,"is_angular":0,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_05_mobilia/MobilIA-main/app/src/api/geocoding.ts","code":"import axios from 'axios';\nimport { getCurrentLocation } from '../utils/geolocation';\n\ninterface ReverseGeocodeResult {\n    features: {\n        properties: {\n            label: string;\n            score: number;\n            housenumber: string;\n            id: string;\n            name: string;\n            postcode: string;\n            citycode: string;\n            x: number;\n            y: number;\n            city: string;\n            context: string;\n            type: string;\n            importance: number;\n            street: string;\n        };\n    }[];\n}\n\nexport async function reverseGeocode(lat: number, lon: number): Promise<string> {\n\n    \n    try {\n        const response = await axios.get<ReverseGeocodeResult>(\n            `https://api-adresse.data.gouv.fr/reverse/?lon=${lon}&lat=${lat}`\n        );\n\n        if (response.data.features.length > 0) {\n            const address = response.data.features[0].properties;\n            return `${address.housenumber || ''} ${address.street}, ${address.postcode} ${address.city}`.trim();\n        } else {\n            throw new Error('No address found for the given coordinates');\n        }\n    } catch (error) {\n        console.error('Error in reverse geocoding:', error);\n        throw error;\n    }\n}\n\ninterface GeocodeResult {\n    features: {\n        geometry: {\n            coordinates: [number, number];\n        };\n        properties: {\n            label: string;\n            score: number;\n            id: string;\n            name: string;\n            postcode: string;\n            citycode: string;\n            x: number;\n            y: number;\n            city: string;\n            context: string;\n            type: string;\n            importance: number;\n            street?: string;\n        };\n    }[];\n}\n\nexport async function geocode(address: string): Promise<{ lat: number; lon: number; label: string }[]> {\n    try {\n        const { latitude, longitude } = await getCurrentLocation();\n        const response = await axios.get<GeocodeResult>(\n            `https://api-adresse.data.gouv.fr/search/?q=${encodeURIComponent(address)}&limit=10&lat=${latitude}&lon=${longitude}`\n        );\n\n        if (response.data.features.length > 0) {\n            return response.data.features.map(feature => {\n                const [lon, lat] = feature.geometry.coordinates;\n                return {\n                    lat,\n                    lon,\n                    label: feature.properties.label\n                };\n            });\n        } else {\n            throw new Error('No coordinates found for the given address');\n        }\n    } catch (error) {\n        console.error('Error in geocoding:', error);\n        throw error;\n    }\n}","description":"Ce fichier contient des fonctions pour la géocodage et le géocodage inverse en utilisant l'API de l'adresse de data.gouv.fr. Il permet de convertir des adresses en coordonnées géographiques et vice versa.","reutilisabilite":"Les fonctions `geocode` et `reverseGeocode` sont réutilisables pour toute application nécessitant la conversion entre adresses et coordonnées géographiques, ce qui est essentiel pour les services de localisation.","specificites_fonctionnelles":"Facilite la conversion entre adresses et coordonnées géographiques, ce qui est crucial pour les applications de mobilité et de cartographie.","value_index":0.0007421150278293135}
{"themes":"Utilisation d\\'autres API, Utilisation de LangChain, ","id_pepite":100,"equipe":"equipe_06_mob_ia","langage":"PYTHON","is_api_idfm":0,"is_api_autres":1,"is_appel_llm":0,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":1,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":0,"is_geocoding":0,"is_angular":0,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_06_mob_ia/hackathon_idfm_octo_2024-main/sources/agent/tools/get_itineraire.py","code":"from typing import Annotated, Literal, Optional\n\nfrom langchain_core.tools import tool\n\nfrom sources.api.api_prim import call_recherche_itineraire\n\n\n@tool\ndef get_itineraire(\n    origin: Annotated[\n        str, \"[Not null] Point de départ : une adresse ou une geolocation sous forme float;float.\"],\n    destination: Annotated[\n        str, \"[Not null] Destination de l'itineraire recherché sous la forme d'une adresse.\"],\n    jour: Annotated[\n        str, (\"[Not null] Jour à laquelle l'utilisateur veut partir au format : YYYYmmdd,\"\n              \"Date de départ ou d’arrivée en fonction du paramètre datetime_represents\")],\n    heure: Annotated[\n        str, (\"[Not null] Heure à laquelle l'utilisateur veut partir au format : HHMMSS\"\n              \"Date de départ ou d’arrivée en fonction du paramètre datetime_represents\")],\n    datetime_represents: Annotated[\n        Optional[Literal['depart', 'arrivée']],\n        \"Si la date et l'heure correspondent à l'heure de départ ou d'arrivée.\"] = 'departure',\n    max_walking_duration_to_pt: Annotated[\n        int, \"Durée maximale de marche sur l'itineraire, en secondes si précisée.\"] = None,\n    wheelchair: Annotated[\n        bool, (\"Si True, le voyageur est considéré comme utilisant un fauteuil roulant\"\n               \"et seuls les transports publics accessibles sont utilisés.\")] = False,\n) -> str:\n    \"\"\"\n        Effectue une recherche d'itineraire permettant d'aller de origin à destination\n        à une date donnée ou pour une date donnée.\n    \"\"\"\n    try:\n        datetime_represents = \"arrival\" if datetime_represents == \"arrivée\" else 'departure'\n        date_str = jour + \"T\" + heure\n        return call_recherche_itineraire(\n            origin=origin, destination=destination,\n            date=date_str,\n            datetime_represents=datetime_represents,\n            max_walking_duration_to_pt=max_walking_duration_to_pt,\n            wheelchair=wheelchair\n        )\n    except Exception as err:\n        return f\"Une erreur est survenue lors de la recherche d'itineraire: {err}\"","description":"Cette fonction effectue une recherche d'itinéraire entre un point de départ et une destination, en tenant compte de divers paramètres comme la date, l'heure, et l'accessibilité.","reutilisabilite":"La fonction est hautement réutilisable pour toute application nécessitant des calculs d'itinéraires personnalisés en Île-de-France.","specificites_fonctionnelles":"Répond au besoin de calculer des itinéraires personnalisés, y compris pour les personnes à mobilité réduite.","value_index":0.0009775171065493646}
{"themes":"Utilisation d\\'un référentiel d\\'événements, Utilisation de Retrieval-Augmented Generation (RAG), ","id_pepite":105,"equipe":"equipe_08_maidfm - Hackathon-IDFM-main","langage":"PYTHON","is_api_idfm":0,"is_api_autres":0,"is_appel_llm":0,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":1,"is_datalake":0,"is_rag":1,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":0,"is_geocoding":0,"is_angular":0,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_08_maidfm%20%-%20%Hackathon-IDFM-main/domain/clusterisation.py","code":"class UserClustering:\n    def __init__(self, n_clusters=3):\n        self.n_clusters = n_clusters\n        self.label_encoders = {}\n        self.scaler = StandardScaler()\n        self.kmeans = KMeans(n_clusters=n_clusters, random_state=42)\n        \n    def preprocess_data_for_knn(self, df):\n        df = df.copy()\n        \n        le = LabelEncoder()\n        df['billettique_type'] = le.fit_transform(df['billettique_type'])\n        \n        df['billettique_tickets_left'] = df['billettique_tickets_left'].fillna(0)\n        \n        df['PMR'] = df['PMR'].astype(int)\n        \n        mlb = MultiLabelBinarizer()\n        interests = df[\"centres d'intérêts\"].apply(eval)\n        interest_encoded = mlb.fit_transform(interests)\n        interest_df = pd.DataFrame(interest_encoded, columns=mlb.classes_, index=df.index)\n        df = pd.concat([df, interest_df], axis=1)\n        df.drop(columns=[\"centres d'intérêts\"], inplace=True)\n        \n        df['nombre_trajets'] = df['trajets'].apply(lambda x: len(eval(x)))\n        df.drop(columns=['trajets'], inplace=True)\n        \n        def average_coordinates(lieux):\n            lieux = eval(lieux)\n            avg_lat = np.mean([coord[0] for coord in lieux])\n            avg_lon = np.mean([coord[1] for coord in lieux])\n            return avg_lat, avg_lon\n\n        df[['lieux_avg_lat', 'lieux_avg_lon']] = df['lieux favoris'].apply(\n            lambda x: pd.Series(average_coordinates(x))\n        )\n        df.drop(columns=['lieux favoris'], inplace=True)\n        \n        numeric_cols = ['km de marche dans les 90 derniers jours', 'intérêt événements']\n        \n        return df[numeric_cols + ['user_id', 'billettique_type', 'billettique_tickets_left', 'PMR', \n                                'nombre_trajets', 'lieux_avg_lat', 'lieux_avg_lon'] + list(mlb.classes_)]\n\n    def fit_transform(self, df):\n        processed_df = pd.DataFrame()\n        processed_df['user_id'] = df['user_id']\n\n        processed_df = self.preprocess_data_for_knn(df)\n        \n        features = processed_df.drop('user_id', axis=1).values\n        scaled_features = self.scaler.fit_transform(features)\n        \n        clusters = self.kmeans.fit_predict(scaled_features)\n        \n        result = pd.DataFrame({\n            'user_id': df['user_id'],\n            'cluster': clusters\n        })\n        \n        return result","description":"Cette classe effectue la clusterisation des utilisateurs en fonction de leurs données personnelles et de leurs comportements, en utilisant l'algorithme KMeans.","reutilisabilite":"La classe est hautement réutilisable pour tout projet nécessitant une segmentation des utilisateurs basée sur des caractéristiques multiples, grâce à son approche modulaire et paramétrable.","specificites_fonctionnelles":"Permet de segmenter les utilisateurs pour des analyses ou des actions marketing ciblées.","value_index":0.0008521516829995739}
{"themes":"Utilisation de LangChain, ","id_pepite":57,"equipe":"equipe_04_mobiwize - ai-framework-main","langage":"JAVASCRIPT","is_api_idfm":0,"is_api_autres":0,"is_appel_llm":0,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":1,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":0,"is_geocoding":0,"is_angular":0,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_04_mobiwize%20%-%20%ai-framework-main/https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/blob/main/packages/ai-toolkit/src/tools/format.ts","code":"import {tool} from \"@langchain/core/tools\";\n\nexport const formatTool = tool(\n  () => {\n\n  },\n  {\n    name: \"format_tool\",\n    description:\n      \"This tool should be called when the informations are available it can end the integration\",\n  }\n)","description":"Ce code définit un outil de formatage générique, prêt à être utilisé dans un cadre plus large où des informations doivent être formatées ou traitées.","reutilisabilite":"Ce code est réutilisable comme un modèle pour créer des outils de traitement ou de formatage dans des applications nécessitant une telle fonctionnalité.","specificites_fonctionnelles":"Fournit une structure de base pour l'intégration d'outils de formatage dans des applications, avec une description et un nom configurables.","value_index":0.00411522633744856}
{"themes":"Utilisation de Retrieval-Augmented Generation (RAG), ","id_pepite":72,"equipe":"equipe_04_mobiwize","langage":"JAVASCRIPT","is_api_idfm":0,"is_api_autres":0,"is_appel_llm":0,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":1,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":0,"is_geocoding":0,"is_angular":0,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_04_mobiwize/ai-framework-main/packages/ai-toolkit/src/graphs/rag/index.ts","code":"export const conductResearch = async (state: typeof RetrievalGraphAnnotation.State): Promise<RetrievalGraphReturnType> => { if (!state.steps || state.steps.length === 0) { throw new Error(\"No research steps found\"); } const result = await researcherGraph.invoke({ question: state.steps[0], messages: [] }); return { documents: result.documents, steps: state.steps.slice(1) }; };","description":"Cette fonction exécute la recherche en utilisant les étapes définies dans le plan de recherche et invoque le graphe de recherche pour obtenir des documents pertinents.","reutilisabilite":"Le code est conçu pour être réutilisé dans différents contextes de recherche en utilisant un graphe de recherche modulaire.","specificites_fonctionnelles":"Permet l'exécution séquentielle des étapes de recherche définies.","value_index":0.0026455026455026454}
{"themes":"Utilisation de Retrieval-Augmented Generation (RAG), Conception de prompts, ","id_pepite":37,"equipe":"equipe_04_mobiwize","langage":"JAVASCRIPT","is_api_idfm":0,"is_api_autres":0,"is_appel_llm":0,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":1,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":1,"is_geocoding":0,"is_angular":0,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_04_mobiwize/ai-framework-main/packages/ai-toolkit/src/graphs/rag/prompts.ts","code":"export const RETRIEVAL_PROMPTS = { ROUTER_SYSTEM_PROMPT: `You are a research assistant...`, GENERAL_SYSTEM_PROMPT: `You are a research assistant...`, MORE_INFO_SYSTEM_PROMPT: `You are a research assistant...`, RESEARCH_PLAN_SYSTEM_PROMPT: `You are an expert researcher...`, RESPONSE_SYSTEM_PROMPT: `You are an expert researcher...` } as const;","description":"Définit un ensemble de prompts utilisés pour guider le système de récupération d'informations dans différentes situations.","reutilisabilite":"Les prompts sont centralisés et peuvent être facilement modifiés ou étendus pour d'autres systèmes de récupération d'informations.","specificites_fonctionnelles":"Fournit des instructions claires pour guider le comportement du système de recherche.","value_index":0.0058309037900874635}
{"themes":"Utilisation de Retrieval-Augmented Generation (RAG), Traitement audio ou vocal, Utilisation de Websockets, Utilisation d\\'Angular, ","id_pepite":88,"equipe":"equipe_09_alterego","langage":"JAVASCRIPT","is_api_idfm":0,"is_api_autres":0,"is_appel_llm":0,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":1,"is_audio_vocal":1,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":1,"is_prompt_design":0,"is_geocoding":0,"is_angular":1,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_09_alterego/idfm_hackaton_2024-main/frontend-angular/src/app/services/audio-recorder.service.ts","code":"import { Injectable } from '@angular/core';\nimport { Observable, Subject } from 'rxjs';\nimport { RecordedAudioOutput } from '../models/recorded-audio-output.model';\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class AudioRecorderService {\n  private recorder!: MediaRecorder;\n  private stream!: MediaStream;\n  private startTime!: Date;\n  private interval: any;\n  private _recorded: Subject<RecordedAudioOutput> = new Subject<RecordedAudioOutput>();\n  private _recordingTime = new Subject<string>();\n  private _recordingFailed = new Subject<string>();\n\n  getRecorded(): Observable<RecordedAudioOutput> {\n    return this._recorded.asObservable();\n  }\n\n  getRecordedTime(): Observable<string> {\n    return this._recordingTime.asObservable();\n  }\n\n  getRecordingFailed(): Observable<string> {\n    return this._recordingFailed.asObservable();\n  }\n\n  startRecording() {\n    if (this.recorder) {\n      return;\n    }\n    let chunks : Blob[] = [];\n\n    navigator.mediaDevices.getUserMedia({ audio: true })\n      .then(stream => {\n        this.stream = stream;\n        this.recorder = new MediaRecorder(this.stream, { mimeType: 'audio/webm' });\n        this.recorder.ondataavailable = (event: BlobEvent) => {\n          chunks.push(event.data);\n        }\n\n        this.recorder.onstop = () => {\n            this._recorded.next({ blob: new Blob(chunks, {type : 'audio/webm'}), duration: new Date().getTime() - this.startTime.getTime(), title: 'audio.webm' });\n        }\n        this.recorder.start();\n        this.startTime = new Date();\n        this.interval = setInterval(() => {\n          const currentTime = new Date();\n          const diffTime = currentTime.getTime() - this.startTime.getTime();\n          const minutes = Math.floor(diffTime / 60000);\n          const seconds = Math.floor((diffTime % 60000) / 1000);\n          const time = this.toString(minutes) + ':' + this.toString(seconds);\n          this._recordingTime.next(time);\n        }, 1000);\n      })\n      .catch(() => {\n        this._recordingFailed.next('Error recording');\n      });\n  }\n\n  stopRecording() {\n    if (this.recorder ) {\n      this.recorder.stop();\n      clearInterval(this.interval);\n    }\n  }\n\n  abortRecording() {\n    this.stopRecording();\n  }\n\n  private toString(value: number): string {\n    return value < 10 ? '0' + value : value.toString();\n  }\n}","description":"Ce service Angular permet d'enregistrer de l'audio à partir du microphone de l'utilisateur. Il utilise l'API MediaRecorder pour capturer l'audio et RxJS pour gérer les flux de données asynchrones.","reutilisabilite":"Le service est modulaire et peut être réutilisé dans n'importe quelle application Angular nécessitant une fonctionnalité d'enregistrement audio. Il encapsule la logique complexe de l'enregistrement audio et fournit une interface simple via des observables.","specificites_fonctionnelles":"Répond au besoin d'enregistrement audio dans une application web, avec gestion des erreurs et suivi du temps d'enregistrement.","value_index":0.0017196904557179708}
{"themes":"Utilisation de Retrieval-Augmented Generation (RAG), Utilisation de LangChain, Conception de prompts, ","id_pepite":46,"equipe":"equipe_08_maidfm","langage":"PYTHON","is_api_idfm":0,"is_api_autres":0,"is_appel_llm":0,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":1,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":1,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":1,"is_geocoding":0,"is_angular":0,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_08_maidfm/Hackathon-IDFM-main/notebooks/HIAM2024","code":"from langchain_core.prompts import PromptTemplate\n\ntemplate = \"\"\"\nTu es un agent d'assistance de recherche documentaire d'île de France mobilité (IDFM),\nà partir des documents donnés donne toujours une réponse provenant du contexte.\nNe donne pas de réponse si le contexte ne te le permet pas.\nRépond de manière concise, en trois phrases maximum.\nRépond dans la langue de la question\nInclut toujours un extrait textuel des documents.\n\nOn dispose du contexte suivants : {context}\n\nUtilisateur : \"{question}\"\nChat bot :\n\"\"\"\ncustom_rag_prompt = PromptTemplate.from_template(template)","description":"Ce code définit un prompt personnalisé pour un modèle de RAG, spécifiant comment le modèle doit répondre aux questions en utilisant le contexte fourni.","reutilisabilite":"Le prompt est adaptable pour diverses applications de RAG, facilitant l'intégration de données contextuelles dans les réponses générées par l'IA.","specificites_fonctionnelles":"Assure que les réponses générées sont basées sur le contexte des documents, ce qui est crucial pour la précision des informations fournies.","value_index":0.0051813471502590676}
{"themes":"Utilisation de Websockets, ","id_pepite":23,"equipe":"equipe_05_mobilia","langage":"PYTHON","is_api_idfm":0,"is_api_autres":0,"is_appel_llm":0,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":1,"is_prompt_design":0,"is_geocoding":0,"is_angular":0,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_05_mobilia/MobilIA-main/server/src/server/utils.py","code":"async def websocket_stream(websocket: WebSocket) -> AsyncIterator[str]:\n    ...","description":"Gère un flux de données via WebSocket, permettant la réception continue de messages textuels.","reutilisabilite":"Ce code est réutilisable pour toute application nécessitant une communication en temps réel via WebSocket, en fournissant un modèle de flux asynchrone.","specificites_fonctionnelles":"Permet la gestion de communications en temps réel, utile pour des applications interactives ou de suivi en direct.","value_index":0.012658227848101266}
{"themes":"Utilisation de Websockets, ","id_pepite":24,"equipe":"equipe_05_mobilia - MobilIA","langage":"PYTHON","is_api_idfm":0,"is_api_autres":0,"is_appel_llm":0,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":1,"is_prompt_design":0,"is_geocoding":0,"is_angular":0,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_05_mobilia/MobilIA-main%20%-%20%MobilIA/server/src/langchain_openai_voice/utils.py","code":"async def amerge(**streams: AsyncIterator[T]) -> AsyncIterator[tuple[str, T]]: ...","description":"Cette fonction asynchrone fusionne plusieurs flux asynchrones en un seul flux. Elle utilise asyncio pour gérer les tâches asynchrones et retourne un itérateur asynchrone de tuples contenant la clé du flux et la valeur.","reutilisabilite":"La fonction 'amerge' est précieuse pour sa capacité à combiner plusieurs flux asynchrones en un seul, ce qui est utile dans des applications nécessitant la gestion simultanée de plusieurs sources de données asynchrones.","specificites_fonctionnelles":"Permet de gérer efficacement plusieurs flux de données asynchrones, ce qui est essentiel pour des applications en temps réel.","value_index":0.012195121951219513}
{"themes":"Utilisation de Websockets, ","id_pepite":29,"equipe":"equipe_05_mobilia - MobilIA","langage":"PYTHON","is_api_idfm":0,"is_api_autres":0,"is_appel_llm":0,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":1,"is_prompt_design":0,"is_geocoding":0,"is_angular":0,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_05_mobilia/MobilIA-main%20%-%20%MobilIA/server/src/langchain_openai_voice/__init__.py","code":"@asynccontextmanager async def connect(*, api_key: str, model: str, url: str) -> AsyncGenerator[...]: ...","description":"Cette fonction gère la connexion à l'API OpenAI en utilisant un gestionnaire de contexte asynchrone. Elle envoie et reçoit des messages via un websocket, permettant une interaction en temps réel avec le modèle d'IA.","reutilisabilite":"La fonction 'connect' est hautement réutilisable pour toute application nécessitant une connexion en temps réel avec l'API OpenAI, grâce à son abstraction des détails de connexion et de gestion des websockets.","specificites_fonctionnelles":"Facilite l'intégration avec l'API OpenAI pour des interactions en temps réel, crucial pour des applications vocales ou de chat.","value_index":0.009523809523809525}
{"themes":"Utilisation de l\\'API IDFM, ","id_pepite":5,"equipe":"equipe_05_mobilia","langage":"PYTHON","is_api_idfm":1,"is_api_autres":0,"is_appel_llm":0,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":0,"is_geocoding":0,"is_angular":0,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_05_mobilia/MobilIA-main/api/directions.py","code":"class DirectionsAPI: ...","description":"Cette classe gère les directions en utilisant des points de départ et d'arrivée verbaux, les géocode en coordonnées, et récupère les informations de trajet via l'API PRIM.","reutilisabilite":"La classe est modulaire et peut être réutilisée pour intégrer des fonctionnalités de navigation dans d'autres applications. Elle encapsule la logique de géocodage et d'appel à l'API de transport.","specificites_fonctionnelles":"Répond aux besoins de calcul de trajets en temps réel, en tenant compte des perturbations et de l'accessibilité.","value_index":0.041666666666666664}
{"themes":"Utilisation de l\\'API IDFM, ","id_pepite":10,"equipe":"equipe_06_mob_ia","langage":"PYTHON","is_api_idfm":1,"is_api_autres":0,"is_appel_llm":0,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":0,"is_geocoding":0,"is_angular":0,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_06_mob_ia/hackathon_idfm_octo_2024-main/sources/api/api_prim.py","code":"def call_recherche_itineraire(...): ...","description":"Cette fonction appelle l'API PRIM pour rechercher un itinéraire entre une origine et une destination, avec des options pour la date, l'heure, et l'accessibilité.","reutilisabilite":"La fonction est hautement réutilisable pour toute application nécessitant des calculs d'itinéraires, en particulier avec des considérations d'accessibilité.","specificites_fonctionnelles":"Gère les itinéraires en tenant compte des besoins spécifiques comme l'accessibilité pour les fauteuils roulants.","value_index":0.02564102564102564}
{"themes":"Utilisation de l\\'API IDFM, ","id_pepite":19,"equipe":"equipe_06_mob_ia","langage":"PYTHON","is_api_idfm":1,"is_api_autres":0,"is_appel_llm":0,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":0,"is_geocoding":0,"is_angular":0,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_06_mob_ia/hackathon_idfm_octo_2024-main/sources/api/api_prim.py","code":"def call_info_trafic(ligne: str | None = None) -> pd.DataFrame: ...","description":"Cette fonction récupère les informations de trafic pour une ligne donnée en utilisant l'API PRIM.","reutilisabilite":"Utile pour toute application nécessitant des mises à jour en temps réel sur l'état du trafic des lignes de transport.","specificites_fonctionnelles":"Fournit des informations sur les perturbations de trafic pour des lignes spécifiques.","value_index":0.014925373134328358}
{"themes":"Utilisation de l\\'API IDFM, ","id_pepite":51,"equipe":"equipe_04_mobiwize - ai-framework-main","langage":"JAVASCRIPT","is_api_idfm":1,"is_api_autres":0,"is_appel_llm":0,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":0,"is_geocoding":0,"is_angular":0,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_04_mobiwize%20%-%20%ai-framework-main/packages/ui/.eslintrc.js","code":"/** @type {import(\"eslint\").Linter.Config} */\nmodule.exports = {\n  root: true,\n  extends: ['@repo/eslint-config/react-internal.js'],\n  parser: '@typescript-eslint/parser',\n  rules: {\n    'no-redeclare': 'off',\n  },\n};","description":"Configuration ESLint pour le package UI, étendant une configuration interne et désactivant la règle 'no-redeclare'.","reutilisabilite":"Permet de réutiliser une configuration ESLint standardisée pour les composants UI, facilitant la gestion des règles de codage.","specificites_fonctionnelles":"Assure la conformité du code UI avec les standards internes tout en permettant des exceptions spécifiques comme 'no-redeclare'.","value_index":0.004608294930875576}
{"themes":"Utilisation de l\\'API IDFM, ","id_pepite":68,"equipe":"equipe_09_alterego","langage":"PYTHON","is_api_idfm":1,"is_api_autres":0,"is_appel_llm":0,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":0,"is_geocoding":0,"is_angular":0,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_09_alterego/idfm_hackaton_2024-main/https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/blob/main/dump.py","code":"def parse_exclusion_file(file_path: str) -> Set[str]:\n    patterns = set()\n    if file_path and os.path.exists(file_path):\n        with open(file_path, 'r') as f:\n            for line in f:\n                line = line.strip()\n                if line and not line.startswith('#'):\n                    patterns.add(line)\n    return patterns","description":"Cette fonction lit un fichier d'exclusion et extrait les motifs d'exclusion, les stockant dans un ensemble pour une utilisation ultérieure.","reutilisabilite":"La fonction est réutilisable pour tout projet nécessitant de gérer des motifs d'exclusion à partir d'un fichier, ce qui est courant dans les scripts de traitement de fichiers ou de répertoires.","specificites_fonctionnelles":"Permet de filtrer les fichiers ou répertoires à exclure lors de l'analyse de la structure de fichiers.","value_index":0.0029585798816568047}
{"themes":"Utilisation de l\\'API IDFM, ","id_pepite":79,"equipe":"equipe_09_alterego","langage":"PYTHON","is_api_idfm":1,"is_api_autres":0,"is_appel_llm":0,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":0,"is_geocoding":0,"is_angular":0,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_09_alterego/idfm_hackaton_2024-main/backend/api-ml-model/notebooks/route.py","code":"dlong = \"2.33792\"\ndlat = \"48.85827\"\nalong = \"2.3588523\"\nalat = \"48.9271087\"\n\njour = \"20241121T073000\"\n\ndestination = dlong + \"%3B%20\" + dlat + \"&to=\" + along + \"%3B%20\" + alat + \"&datetime=\" + jour\nurl = 'https://prim.iledefrance-mobilites.fr/marketplace/v2/navitia/journeys?from=' + destination\n\nheaders = {'Accept': 'application/json', 'apikey': apikey}\n\nreq = requests.get(url, headers=headers)\n\nprint('Status:',req)\n\ndata = pd.json_normalize(req.json())","description":"Ce code envoie une requête à l'API PRIM pour obtenir des informations de trajet entre deux points géographiques à une date et heure spécifiées. Il utilise les coordonnées de départ et d'arrivée pour construire l'URL de la requête et affiche le statut de la réponse.","reutilisabilite":"Le code est réutilisable pour toute application nécessitant l'accès aux données de trajet de l'API PRIM. Il montre comment formater les requêtes et traiter les réponses JSON, ce qui est utile pour l'intégration de services de mobilité.","specificites_fonctionnelles":"Le code permet de récupérer des informations de trajet spécifiques à une date et heure données, ce qui est crucial pour les applications de planification de voyage.","value_index":0.002188183807439825}
{"themes":"Utilisation de l\\'API IDFM, ","id_pepite":99,"equipe":"equipe_05_mobilia","langage":"PYTHON","is_api_idfm":1,"is_api_autres":0,"is_appel_llm":0,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":0,"is_geocoding":0,"is_angular":0,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_05_mobilia/MobilIA-main/navigation-api/apiNavCommunication.py","code":"from requests.auth import HTTPBasicAuth\nimport requests\nimport json\nimport pandas as pd\n\n# TOKEN: XDJujSkUHlvvCOirYONTwk9953G7thie\nTOKEN = 'XDJujSkUHlvvCOirYONTwk9953G7thie'\n\n# Affectation des coordonnées au départ et à l'arrivée\ndlong = \"2.33792\"\ndlat = \"48.85827\"\nalong = \"2.3588523\"\nalat = \"48.9271087\"\n\n# Date et heure du trajet\njour = \"20241121T073000\"\n\n# URL de l'API\ndestination = dlong + \"%3B%20\" + dlat + \"&to=\" + along + \"%3B%20\" + alat + \"&datetime=\" + jour\nurl = 'https://prim.iledefrance-mobilites.fr/marketplace/v2/navitia/journeys?from=' + destination\n\n# Le header doit contenir la clé API : apikey, remplacer #VOTRE CLE API par votre clé API\nheaders = {'Accept': 'application/json', 'apikey': TOKEN}\n\n# Envoi de la requête au serveur\nreq = requests.get(url, headers=headers)\n\n# Affichage du code réponse\nprint('Status:', req)\n\n# Lecture du json\ndata = pd.json_normalize(req.json())\n\n# Les différents trajets retournés sont dans data['journeys'][0]\nprint(data.head())","description":"Ce script Python envoie une requête à l'API Navitia de PRIM pour obtenir des informations de trajet, puis normalise et affiche les données JSON reçues.","reutilisabilite":"Le script est réutilisable pour toute application nécessitant des informations de trajet en temps réel. Il peut être facilement adapté pour d'autres API de transport ou pour intégrer des fonctionnalités similaires dans d'autres projets.","specificites_fonctionnelles":"Fournit une solution pour récupérer et afficher des informations de trajet, ce qui est essentiel pour des applications de planification de voyages ou de gestion de mobilité.","value_index":0.0010183299389002036}
{"themes":"Utilisation de l\\'API IDFM, ","id_pepite":101,"equipe":"equipe_09_alterego","langage":"PYTHON","is_api_idfm":1,"is_api_autres":0,"is_appel_llm":0,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":0,"is_geocoding":0,"is_angular":0,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_09_alterego/idfm_hackaton_2024-main/backend/api-ml-model/main.py","code":"@app.get(\"/options_and_metadata\")\ndef get_routes():\n    departure = Coordinates(latitude=48.85021352679651,\n                         longitude=2.4735419963428593)\n\n    arrival = Coordinates(latitude=48.875460818207635,\n                                longitude=2.3088650247211775)\n\n    current_time = datetime.now()\n    current_time = current_time.strftime(\"%Y%m%dT%H%M%S\")\n\n    destination = f\"{departure.longitude}%3B%20{departure.latitude}&to={arrival.longitude}%3B%20{arrival.latitude}&datetime={current_time}\"\n    url = f\"https://prim.iledefrance-mobilites.fr/marketplace/v2/navitia/journeys?from={destination}\"\n\n    headers = {\"Accept\": \"application/json\", \"apikey\": api_key}\n\n    # API request\n    response = requests.get(url, headers=headers)\n\n    if response.status_code != 200:\n        raise ValueError(\n            f\"Failed to fetch data. Status code: {response.status_code}, Message: {response.text}\"\n        )\n\n    # Process response\n    try:\n        data = response.json()\n        return data\n    except Exception as e:\n        raise ValueError(f\"Error processing response: {e}\")","description":"Cette fonction définit une route API qui récupère des itinéraires en utilisant l'API PRIM de Île-de-France Mobilités. Elle construit une requête avec des coordonnées de départ et d'arrivée, ainsi qu'une date et heure actuelles, puis envoie une requête GET à l'API PRIM pour obtenir des données de trajet.","reutilisabilite":"Ce code est précieux car il encapsule l'appel à l'API PRIM pour récupérer des itinéraires, ce qui est une fonctionnalité clé pour des applications de mobilité. Il peut être réutilisé dans d'autres projets nécessitant l'intégration avec l'API PRIM pour des fonctionnalités similaires.","specificites_fonctionnelles":"Le code répond au besoin fonctionnel de récupérer des informations de trajet en temps réel, ce qui est essentiel pour les applications de planification de voyage et de mobilité.","value_index":0.0009149130832570906}
{"themes":"Utilisation de l\\'API IDFM, ","id_pepite":104,"equipe":"equipe_09_alterego","langage":"PYTHON","is_api_idfm":1,"is_api_autres":0,"is_appel_llm":0,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":0,"is_geocoding":0,"is_angular":0,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_09_alterego/idfm_hackaton_2024-main/notebooks/route.py","code":"# %%\nimport pandas as pd\nfrom dotenv import load_dotenv\nfrom pathlib import Path\nimport os\n\n# Specify the path to the .env file\nsecrets_path = Path(os.getcwd() + '/../secrets.env').resolve()\nload_dotenv(dotenv_path=secrets_path)\napikey = os.getenv('PRIM')\n\n\n# %%\nfrom requests.auth import HTTPBasicAuth\nimport requests\nimport json\nimport pandas as pd\n\n#Affectation des coordonnées au départ et à l'arrivée\ndlong = \"2.33792\"\ndlat = \"48.85827\"\nalong = \"2.3588523\"\nalat = \"48.9271087\"\n\n#Date et heure du trajet\njour = \"20241121T073000\"\n\n#URL de l'API\ndestination = dlong + \"%3B%20\" + dlat + \"&to=\" + along + \"%3B%20\" + alat + \"&datetime=\" + jour\nurl = 'https://prim.iledefrance-mobilites.fr/marketplace/v2/navitia/journeys?from=' + destination\n\n#Le header doit contenir la clé API : apikey, remplacer #VOTRE CLE API par votre clé API\nheaders = {'Accept': 'application/json', 'apikey': apikey}\n\n#Envoi de la requête au serveur\nreq = requests.get(url, headers=headers)\n\n#Affichage du code réponse\nprint('Status:',req)\n\n#Lecture du json\ndata = pd.json_normalize(req.json())\n# %%\njourneys = data['journeys'][0].pop()\n\n# %%\nfrom IPython.display import JSON\nJSON(journeys)\n\n# %%\n","description":"Ce script Python interagit avec l'API PRIM pour récupérer des informations de trajet entre deux points géographiques à une date et heure spécifiées. Il utilise la bibliothèque requests pour envoyer des requêtes HTTP et pandas pour traiter les données JSON reçues.","reutilisabilite":"Le code est un bon exemple d'intégration avec l'API PRIM pour obtenir des informations de trajet. Il peut être réutilisé dans d'autres projets nécessitant des fonctionnalités similaires de calcul d'itinéraires.","specificites_fonctionnelles":"Permet de calculer des itinéraires en utilisant l'API PRIM, ce qui est essentiel pour des applications de mobilité et de transport.","value_index":0.0008547008547008547}
{"themes":"Utilisation de l\\'API IDFM, ","id_pepite":106,"equipe":"equipe_10_ivoice","langage":"PYTHON","is_api_idfm":1,"is_api_autres":0,"is_appel_llm":0,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":0,"is_geocoding":0,"is_angular":0,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_10_ivoice/ivoice-main/ivoice-main/src/itinerary_data.py","code":"from dataclasses import dataclass\n\n@dataclass\nclass Route:\n    start: str\n    end: str\n    line: str\n\n@dataclass\nclass Itinerary:\n    itinerary_type: str\n    routes: list[Route]\n\n    @classmethod\n    def from_navitia_response(cls, navitia_reponse: dict, itinerary_type: str, start_name: str, destination_name: str):\n        routes = []\n        for section in navitia_reponse[\"journeys\"][0][\"sections\"]:\n            if section[\"type\"] == \"waiting\":\n                continue\n\n            if section[\"type\"] == \"street_network\" and section[\"mode\"] == \"walking\":\n                line = \"A pied\"\n            elif section[\"type\"] == \"public_transport\":\n                line = f\"{section['display_informations']['commercial_mode']} {section['display_informations']['name']}\"\n            else:\n                line = \"Inconnue\"\n\n            routes.append(Route(\n                start=section[\"from\"][\"stop_point\"][\"name\"] if \"stop_point\" in section[\"from\"] else start_name,\n                end=section[\"to\"][\"stop_point\"][\"name\"] if \"stop_point\" in section[\"to\"] else destination_name,\n                line=line\n            ))\n            break\n\n        return Itinerary(itinerary_type, routes)","description":"Ce code définit des classes de données pour représenter des itinéraires et des routes, et inclut une méthode pour créer un objet Itinerary à partir d'une réponse de l'API Navitia.","reutilisabilite":"La méthode from_navitia_response est réutilisable pour transformer les réponses de l'API Navitia en objets Itinerary, facilitant l'intégration avec d'autres systèmes de gestion d'itinéraires.","specificites_fonctionnelles":"Le code permet de convertir les données brutes de l'API Navitia en objets structurés, facilitant leur manipulation et affichage.","value_index":0.0008431703204047217}
{"themes":"Utilisation de l\\'API IDFM, ","id_pepite":109,"equipe":"equipe_05_mobilia","langage":"PYTHON","is_api_idfm":1,"is_api_autres":0,"is_appel_llm":0,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":0,"is_geocoding":0,"is_angular":0,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_05_mobilia/MobilIA-main/api/app.py","code":"directions = DirectionsAPI(api_key=os.getenv('DIRECTIONS_API_KEY', 'REMOVED'))\n\n@app.route('/api/directions', methods=['GET'])\ndef get_directions():\n    try:\n        # Extract parameters from the request\n        origin_long = request.args.get('origin_long')\n        origin_lat = request.args.get('origin_lat')\n        dest_long = request.args.get('dest_long')\n        dest_lat = request.args.get('dest_lat')\n        datetime_str = request.args.get('datetime')\n        wheelchair = request.args.get('wheelchair', 'false').lower() == 'true'\n\n        # Validate required parameters\n        if not all([origin_long, origin_lat, dest_long, dest_lat, datetime_str]):\n            return jsonify({\"error\": \"Missing required parameters\"}), 400\n\n        # Get journey information\n        journey_data = directions.get_journey_info(\n            origin_long, origin_lat, dest_long, dest_lat, datetime_str, wheelchair\n        )\n\n        if journey_data is None:\n            return jsonify({\"error\": \"Failed to fetch journey information\"}), 500\n\n        # Parse journey data\n        parsed_journeys = directions.parse_journey_data(journey_data)\n\n        return jsonify(parsed_journeys)\n\n    except Exception as e:\n        return jsonify({\"error\": str(e)}), 500","description":"Ce code définit une API Flask pour obtenir des directions de voyage en utilisant une API Directions personnalisée. Il extrait les paramètres de la requête, valide les entrées, et renvoie les informations de trajet.","reutilisabilite":"Ce code est réutilisable pour toute application nécessitant des services de direction, en particulier pour des applications de mobilité ou de transport.","specificites_fonctionnelles":"Répond aux besoins de calcul de trajets en tenant compte de l'accessibilité, ce qui est crucial pour les applications de transport inclusif.","value_index":0.0008025682182985554}
{"themes":"Utilisation de l\\'API IDFM, ","id_pepite":112,"equipe":"equipe_09_alterego","langage":"PYTHON","is_api_idfm":1,"is_api_autres":0,"is_appel_llm":0,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":0,"is_geocoding":0,"is_angular":0,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_09_alterego/idfm_hackaton_2024-main/backend/api-ml-model/src/api_mlmodel/journey.py","code":"import requests\nimport pandas as pd\n\nfrom .specification import Coordinates\n\n\ndef get_journeys(\n    api_key: str, departure: Coordinates, arrival: Coordinates, datetime: str\n) -> pd.DataFrame:\n    \"\"\"\n    Fetches journey details from the API.\n\n    Args:\n        api_key (str): API key for authentication.\n        departure (Coordinates): Departure GPS coordinates.\n        arrival (Coordinates): Arrival GPS coordinates.\n        datetime (str): Date and time for the journey in the format YYYYMMDDTHHMMSS.\n\n    Returns:\n        pd.DataFrame: A DataFrame containing journey details.\n    \"\"\"\n    destination = f\"{departure.longitude}%3B%20{departure.latitude}&to={arrival.longitude}%3B%20{arrival.latitude}&datetime={datetime}\"\n    url = f\"https://prim.iledefrance-mobilites.fr/marketplace/v2/navitia/journeys?from={destination}\"\n\n    headers = {\"Accept\": \"application/json\", \"apikey\": api_key}\n\n    # API request\n    response = requests.get(url, headers=headers)\n\n    if response.status_code != 200:\n        raise ValueError(\n            f\"Failed to fetch data. Status code: {response.status_code}, Message: {response.text}\"\n        )\n\n    # Process response\n    try:\n        data = response.json()\n        return data\n    except Exception as e:\n        raise ValueError(f\"Error processing response: {e}\")","description":"Ce code interagit avec l'API PRIM pour récupérer des détails de trajets entre deux coordonnées GPS à une date et heure données.","reutilisabilite":"La fonction est hautement réutilisable pour toute application nécessitant des informations de trajet en Île-de-France, grâce à son abstraction des détails de l'API et son retour sous forme de DataFrame.","specificites_fonctionnelles":"Répond au besoin de récupération de données de trajets pour des applications de mobilité en Île-de-France.","value_index":0.0007668711656441718}
{"themes":"Utilisation de l\\'API IDFM, ","id_pepite":116,"equipe":"equipe_05_mobilia","langage":"PYTHON","is_api_idfm":1,"is_api_autres":0,"is_appel_llm":0,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":0,"is_geocoding":0,"is_angular":0,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_05_mobilia/MobilIA-main/navigation-api/apiNav.ipynb","code":"from requests.auth import HTTPBasicAuth\nimport requests\nimport json\nimport pandas as pd\n\n# API key\nTOKEN = 'XDJujSkUHlvvCOirYONTwk9953G7thie'\n\n# Affectation des coordonnées au départ et à l'arrivée\ndlong = \"2.357795224218518\"\ndlat = \"48.881422645383765\"\nalong = \"2.2858484602361986\"\nalat = \"48.846779058452746\"\n\nwith_wheelchair = True\n\n# Date et heure du trajet\njour = \"20241121T150000\"\n\n# URL de l'API\ndestination = (dlong + \"%3B%20\" + dlat + \"&to=\" + along + \"%3B%20\" + alat + \"&datetime=\" + jour +\n               ('&wheelchair=true&max_duration_to_pt=300&data_freshness=realtime' if with_wheelchair else '&data_freshness=realtime'))\nurl = 'https://prim.iledefrance-mobilites.fr/marketplace/v2/navitia/journeys?from=' + destination\n\n# Le header doit contenir la clé API : apikey, remplacer #VOTRE CLE API par votre clé API\nheaders = {'Accept': 'application/json', 'apikey': TOKEN}\n\n# Envoi de la requête au serveur\nreq = requests.get(url, headers=headers)\nprint('Status:', req)\n\nwith open('response.json', 'w') as response:\n    json.dump(req.json(), response, indent=4)\n\n# Lecture du json\ndata_json = req.json()\n# data = pd.json_normalize(req.json())\n\n# Les différents trajets retournés sont dans data['journeys'][0]\nprint(data_json['journeys'][0]['distances'])\n\njourneys = list()\n\nlabels = ['walking_distance']\n\nfor journey in data_json['journeys']:\n    infos = list()\n    infos.append(journey['distances']['walking'])\n    journeys.append(infos)\n    \ndf_journeys = pd.DataFrame(journeys, columns=labels)\ndf_journeys","description":"Ce notebook Jupyter interagit avec l'API Navitia de PRIM pour obtenir des informations de trajet entre deux points géographiques, en tenant compte de l'accessibilité pour les fauteuils roulants.","reutilisabilite":"Le code est précieux pour les applications nécessitant des calculs de trajets en temps réel, en particulier celles qui doivent prendre en compte l'accessibilité. Il peut être adapté pour d'autres services de transport ou d'itinéraires.","specificites_fonctionnelles":"Répond aux besoins de planification de trajets en temps réel, avec une attention particulière à l'accessibilité pour les utilisateurs en fauteuil roulant.","value_index":0.0006587615283267457}
{"themes":"Utilisation de l\\'API IDFM, ","id_pepite":117,"equipe":"equipe_10_ivoice","langage":"PYTHON","is_api_idfm":1,"is_api_autres":0,"is_appel_llm":0,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":0,"is_geocoding":0,"is_angular":0,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_10_ivoice/ivoice-main/src/itinerary.py","code":"import os\nimport requests\nfrom datetime import datetime\nfrom dotenv import load_dotenv\nfrom dataloaders import load_arrets_et_lignes_associes\n\nAPI_URL = \"https://prim.iledefrance-mobilites.fr/marketplace/v2/navitia/\"\n\ndef get_station_pos(station_id: str):\n    station_data = load_arrets_et_lignes_associes()\n    station_lon = station_data[station_data[\"stop_id\"] == station_id][\"stop_lon\"].head(1).item()\n    station_lat = station_data[station_data[\"stop_id\"] == station_id][\"stop_lat\"].head(1).item()\n    return (station_lon, station_lat)\n\ndef basic_itinerary(start_station_id: str, end_station_id: str, departure_time: datetime) -> dict:\n    start_station_pos = get_station_pos(start_station_id)\n    end_station_pos = get_station_pos(end_station_id)\n    parameters = {\n        \"from\": \";\".join(start_station_pos),\n        \"to\": \";\".join(end_station_pos),\n        \"datetime\": departure_time,\n    }\n    response = requests.get(url=API_URL, params=parameters, headers={\"apiKey\": os.environ[\"IDFM_API_KEY\"]})\n    return response.json()\n\ndef itinerary_with_line_exclusion(start_station_id: str, end_station_id: str, departure_time: datetime, excluded_line_id: str) -> dict:\n    start_station_pos = get_station_pos(start_station_id)\n    end_station_pos = get_station_pos(end_station_id)\n    forbidden_uri = f\"line:{excluded_line_id}\"\n    parameters = {\n        \"from\": \";\".join(start_station_pos),\n        \"to\": \";\".join(end_station_pos),\n        \"datetime\": departure_time,\n        \"forbidden_uris[]\": forbidden_uri,\n    }\n    response = requests.get(url=f\"{API_URL}/journeys\", params=parameters, headers={\"apiKey\": os.environ[\"IDFM_API_KEY\"]})\n    return response.json()","description":"Ce code interagit avec l'API PRIM pour obtenir des itinéraires de transport en commun, avec la possibilité d'exclure certaines lignes.","reutilisabilite":"Les fonctions d'itinéraire sont modulaires et peuvent être réutilisées pour toute application nécessitant des calculs d'itinéraires basés sur l'API PRIM.","specificites_fonctionnelles":"Le code permet de calculer des itinéraires en transport en commun, ce qui est crucial pour les applications de mobilité.","value_index":0.0005995203836930455}
{"themes":"Utilisation de l\\'API IDFM, ","id_pepite":118,"equipe":"equipe_06_mob_ia","langage":"PYTHON","is_api_idfm":1,"is_api_autres":0,"is_appel_llm":0,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":0,"is_geocoding":0,"is_angular":0,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_06_mob_ia/hackathon_idfm_octo_2024-main/sources/entities/process_dico.py","code":"def process_dico(response: dict) -> dict:\n    dicomax = {}\n\n    itineraire = response['journeys'][0][0]\n\n    etapes = {}\n\n    for idx, step in enumerate(itineraire['sections']):\n        try:\n            etapes[idx] = {\n                'durée': step['duration'],\n                'arrivée': step['to']['name'],\n                'départ': step['from']['name'],\n                'chemin': {}\n            }\n        except KeyError:\n            continue\n        if 'path' in step:\n            for idx2, _ in enumerate(step['path']):\n                etapes[idx]['chemin'][idx2] = step['path'][idx2]['instruction']\n            etapes[idx]['mode de mobilité'] = 'marche'\n        else:\n            try:\n                etapes[idx]['chemin']['direction'] = step['display_informations']['direction']\n                etapes[idx]['mode de mobilité'] = (\n                    step['display_informations']['commercial_mode'] + ' ' +\n                    step['display_informations']['label'])\n            except KeyError:\n                continue\n\n    dicomax[f'Itineraire {itineraire['type']}'] = {\n        'duration': itineraire['duration'],\n        'nombre changement': itineraire['nb_transfers'],\n        'heure de départ': itineraire['departure_date_time'],\n        'heure d'arrivée': itineraire['arrival_date_time'],\n        'heure demandée': itineraire['requested_date_time'],\n        'distance marche': itineraire['distances']['walking'],\n        'prix du trajet': itineraire['fare'],\n        'étapes': etapes,\n    }\n\n    dicomax['problèmes'] = {}\n    try:\n        for idx, pb in enumerate(response['disruptions'][0]):\n            source_pb = pb['messages'][1]['text'].split(' ')[0]\n            dicomax['problèmes'][f'{source_pb}_{idx}'] = pb['messages'][1]['text'][len(source_pb):]\n    except KeyError:\n        pass\n\n    return dicomax","description":"Ce code traite une réponse JSON contenant des informations sur un itinéraire et extrait des détails pertinents pour les étapes du trajet, les disruptions, et d'autres métadonnées.","reutilisabilite":"La fonction est précieuse pour toute application nécessitant le traitement et l'analyse de données d'itinéraires, notamment dans le contexte des transports en commun.","specificites_fonctionnelles":"Répond à un besoin de traitement et d'analyse des données d'itinéraires pour les transports en commun.","value_index":0.0005482456140350877}
{"themes":"Utilisation de l\\'API IDFM, ","id_pepite":122,"equipe":"equipe_10_ivoice","langage":"PYTHON","is_api_idfm":1,"is_api_autres":0,"is_appel_llm":0,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":0,"is_geocoding":0,"is_angular":0,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_10_ivoice/ivoice-main/src/itinerary_calculator.py","code":"from itinerary_data import Itinerary, Route\nfrom dataloaders import load_arrets_et_lignes_associes\nfrom itinerary import itinerary_with_line_exclusion\nfrom datetime import datetime\nfrom pathlib import Path\nimport json\nfrom dacite import from_dict\nfrom dataclasses import asdict\n\nclass ItineraryCalculator:\n    def __init__(self):\n        self.stations_by_lines = load_arrets_et_lignes_associes()\n        self.standard_destination_ids = [\"IDFM:483454\", \"IDFM:491486\", \"IDFM:22073\", \"IDFM:5823\"]\n        self.standard_itinerary_types = [\"Centre de Paris\", \"Grands Boulevards\", \"Est de Paris\", \"Ouest de Paris\"]\n\n    def compute_alternate_itineraries(self, line_id: str) -> dict[str, Itinerary]:\n        cache_file_path = Path(f\"data/{line_id.split(':')[-1]}_cache.json\")\n        if cache_file_path.is_file():\n            with cache_file_path.open('r', encoding=\"utf-8\") as f:\n                data = json.load(f)\n                for key, val in data.items():\n                    data[key] = [from_dict(Itinerary, it) for it in val]\n            return data\n        station_ids = self.stations_by_lines[self.stations_by_lines[\"id\"] == line_id][\"stop_id\"]\n        alt_itineraries = {}\n        for station_id in station_ids:\n            station_name = self.stations_by_lines[self.stations_by_lines[\"stop_id\"] == station_id][\"stop_name\"].head(1).item()\n            alt_itineraries[station_name] = []\n            for std_destination_id, std_itin_type in zip(self.standard_destination_ids, self.standard_itinerary_types):\n                destination_name = self.stations_by_lines[self.stations_by_lines[\"stop_id\"] == std_destination_id][\"stop_name\"].head(1).item()\n                itin = itinerary_with_line_exclusion(station_id, std_destination_id, datetime.now(), line_id)\n                alt_itineraries[station_name].append(Itinerary.from_navitia_response(itin, std_itin_type, station_name, destination_name))\n        cache_file_path.parent.mkdir(parents=True, exist_ok=True)\n        with cache_file_path.open(\"w\", encoding=\"utf-8\") as f:\n            data = {k: [asdict(it) for it in v] for k, v in alt_itineraries.items()}\n            json.dump(data, f, ensure_ascii=False)\n        return alt_itineraries","description":"Cette classe calcule des itinéraires alternatifs en excluant certaines lignes, et utilise un cache pour stocker les résultats.","reutilisabilite":"La classe ItineraryCalculator est hautement réutilisable pour toute application nécessitant des calculs d'itinéraires alternatifs avec exclusion de lignes.","specificites_fonctionnelles":"Le code permet de calculer des itinéraires alternatifs, ce qui est essentiel pour offrir des options de transport flexibles aux utilisateurs.","value_index":0.00045475216007276033}
{"themes":"Utilisation de l\\'API IDFM, Appel à un LLM, ","id_pepite":96,"equipe":"equipe_02_elevate_us","langage":"PYTHON","is_api_idfm":1,"is_api_autres":0,"is_appel_llm":1,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":0,"is_geocoding":0,"is_angular":0,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_02_elevate_us/accessibility-waze-main/signaling.py","code":"import os\nfrom openai import AzureOpenAI\nfrom api_key import API_KEY\n\nCATEGORY_TO_EXPLANATION = {\n    \"Quai\": \"Un problème a été signalé au niveau du quai.\",\n    \"Escalator-fonctionnement\": \"Il semble y avoir un problème avec le fonctionnement de cet escalator.\",\n    \"Escalator-bruit\": \"L'escalator fait un bruit étonnant.\",\n    \"Escalator-propreté\": \"L'escalator est sale.\",\n    \"Ascenseur-fonctionnement\": \"Il semble y avoir un problème avec le fonctionnement de cet ascenseur.\",\n    \"Ascenseur-bruit\": \"L'ascenseur fait un bruit étonnant.\",\n    \"Ascenseur-propreté\": \"L'ascenseur est sale.\",\n    \"problème-inconnu\": \"Problème inconnu\",\n}\n\ndef categorize_signaling(text):\n    API_VERSION = \"2024-08-01-preview\"\n    AZURE_ENDPOINT = \"https://dlb-team02-prd-oai01.openai.azure.com/\"\n\n    azure_open_ai_parameters = {\n        \"api_version\": API_VERSION,\n        \"azure_endpoint\": AZURE_ENDPOINT,\n        \"api_key\": API_KEY,\n    }\n\n    llm = AzureOpenAI(**azure_open_ai_parameters)\n\n    completion = llm.beta.chat.completions.parse(\n        model=\"gpt-4o-mini\",\n        messages=[\n            {\n                \"role\": \"system\",\n                \"content\": \"You will receive the signaling of an equipment in a train station. Your goal is to categorize that signaling between : Quai, Escalator-fonctionnement, Escalator-bruit, Escalator-propreté, Ascenseur-fonctionnement, Ascenseur-bruit, Ascenseur-propreté, problème-inconnu\",\n            },\n            {\"role\": \"user\", \"content\": text},\n        ],\n    )\n\n    return completion.choices[0].message.content","description":"Ce code utilise un modèle de langage d'Azure OpenAI pour classifier les signalements d'équipements en différentes catégories prédéfinies.","reutilisabilite":"La fonction de classification des signalements peut être réutilisée pour d'autres types de signalements ou dans d'autres contextes nécessitant une catégorisation automatique.","specificites_fonctionnelles":"Permet de catégoriser automatiquement les signalements d'équipements pour une gestion plus efficace des problèmes.","value_index":0.001287001287001287}
{"themes":"Utilisation de l\\'API IDFM, Appel à un LLM, Création d\\'une interface utilisateur (IHM), Utilisation de LangChain, ","id_pepite":84,"equipe":"equipe_04_mobiwize - ai-framework-main","langage":"JAVASCRIPT","is_api_idfm":1,"is_api_autres":0,"is_appel_llm":1,"is_creation_ihm":1,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":1,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":0,"is_geocoding":0,"is_angular":0,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_04_mobiwize%20%-%20%ai-framework-main/packages/ai-toolkit/src/graphs/orchestrator/index.ts","code":"// Enhanced node types\nimport {Annotation, END, MessagesAnnotation, START, StateGraph} from \"@langchain/langgraph\";\n\ntype ModelNode = (input: any) => Promise<any>;\ntype ToolNode = (input: any) => Promise<any>;\ntype TransportNode = (input: any) => Promise<any>;\ntype DisruptionNode = (input: any) => Promise<any>;\n\n// Define condition check functions\nconst shouldContinue = (state: any): string => {\n  return \"next\"\n};\n\n// Node implementations\nconst callModel: ModelNode = async (input) => {\n  // Base model call logic\n  return {};\n};\n\nconst toolNode: ToolNode = async (input) => {\n  // Tool execution logic\n  return {};\n};\n\nconst transportNode: TransportNode = async (input) => {\n  // Transport-specific logic (schedules, routes, etc.)\n  return {\n    schedules: [],\n    availableRoutes: [],\n    realTimeStatus: {}\n  };\n};\n\nconst disruptionNode: DisruptionNode = async (input) => {\n  // Disruption handling logic\n  return {\n    activeDisruptions: [],\n    alternativeRoutes: [],\n    estimatedResolution: null\n  };\n};\n\n// Create enhanced workflow graph\nconst workflow = new StateGraph(Annotation.Root({\n  ...MessagesAnnotation.spec,\n}))\n  // Core nodes\n  .addNode(\"cache\", callModel)\n  .addNode(\"router\", callModel)\n  .addNode(\"filter\", callModel)\n  .addNode(\"CONTEXT\", callModel)\n  .addNode(\"JOURNEY_PLANNER\", toolNode)\n  .addNode(\"CUSTOMER_SUPPORT\", toolNode)\n  .addNode(\"TICKETING\", toolNode)\n  .addNode(\"ACCESSIBILITY\", toolNode)\n  .addNode(\"REAL_TIME_TRACKING\", toolNode)\n  .addNode(\"agent\", toolNode)\n  .addNode(\"tools\", toolNode)\n\n  // Base edges\n  .addEdge(START, \"cache\")\n  .addEdge(\"CONTEXT\", \"router\")\n  .addConditionalEdges(\"cache\", shouldContinue, [\"CONTEXT\", END])\n  .addConditionalEdges(\"router\", shouldContinue, [\"JOURNEY_PLANNER\", \"CUSTOMER_SUPPORT\", \"TICKETING\", \"ACCESSIBILITY\", \"REAL_TIME_TRACKING\"])\n  .addEdge(\"JOURNEY_PLANNER\", \"agent\")\n  .addEdge(\"CUSTOMER_SUPPORT\", \"agent\")\n  .addEdge(\"TICKETING\", \"agent\")\n  .addEdge(\"ACCESSIBILITY\", \"agent\")\n  .addEdge(\"tools\", \"agent\")\n  .addEdge(\"REAL_TIME_TRACKING\", \"agent\")\n  .addConditionalEdges(\"agent\", shouldContinue, [\"tools\", \"filter\"])\n  .addEdge(\"filter\", END)\n\nexport const graph = workflow.compile();","description":"Ce code définit un graphe de flux de travail utilisant des nœuds et des arêtes pour orchestrer différentes tâches dans un système de gestion de la mobilité. Les nœuds représentent des appels de modèles, des outils, et des logiques spécifiques au transport et aux perturbations. Le graphe est compilé pour orchestrer les interactions entre ces composants.","reutilisabilite":"Le code est hautement réutilisable grâce à son abstraction et sa modularité. Les nœuds et les arêtes peuvent être facilement adaptés pour intégrer de nouvelles fonctionnalités ou services. Il permet une intégration fluide avec des APIs de mobilité et des outils externes, facilitant ainsi l'extension et la personnalisation du système.","specificites_fonctionnelles":"Le code répond aux besoins fonctionnels de gestion de la mobilité en orchestrant des tâches telles que la planification de trajets, le support client, la billetterie, l'accessibilité, et le suivi en temps réel. Il gère également les perturbations, offrant des routes alternatives et des estimations de résolution.","value_index":0.0018399264029438822}
{"themes":"Utilisation de l\\'API IDFM, Appel à un LLM, Création d\\'une interface utilisateur (IHM), Utilisation de LangChain, Conception de prompts, Génération de données, ","id_pepite":93,"equipe":"equipe_06_mob_ia - hackathon_idfm_octo_2024","langage":"PYTHON","is_api_idfm":1,"is_api_autres":0,"is_appel_llm":1,"is_creation_ihm":1,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":1,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":1,"is_geocoding":0,"is_angular":0,"is_data_generation":1,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_06_mob_ia/hackathon_idfm_octo_2024-main%20%-%20%hackathon_idfm_octo_2024/sources/agent/agent.py","code":"from datetime import datetime\nimport os\n\nfrom langchain.agents import AgentExecutor\nfrom langchain_core.messages import AIMessage, HumanMessage\nfrom langchain_core.prompts import ChatPromptTemplate, MessagesPlaceholder\nfrom langchain_openai import AzureChatOpenAI\n\nfrom sources.agent.tools.get_itineraire import get_itineraire\nfrom sources.agent.tools.get_info_trafic import get_info_trafic\n\n\nfrom langchain.agents.format_scratchpad.openai_tools import (\n    format_to_openai_tool_messages,\n)\nfrom langchain.agents.output_parsers.openai_tools import OpenAIToolsAgentOutputParser\n\nAPI_VERSION = os.getenv('AZURE_OPENAI_API_VERSION')\nAZURE_ENDPOINT = os.getenv('AZURE_OPENAI_ENDPOINT')\nAPI_KEY = os.getenv('AZURE_OPENAI_API_KEY')\n\nMEMORY_KEY = \"chat_history\"\nCHAT_HISTORY = []\n\nTOOLS = [get_itineraire, get_info_trafic]\n\nazure_open_ai_parameters = {\n    \"api_version\": API_VERSION,\n    \"azure_endpoint\": AZURE_ENDPOINT,\n    \"api_key\": API_KEY\n}\n\nllm = AzureChatOpenAI(\n    **azure_open_ai_parameters,\n    model=os.getenv('AZURE_OPENAI_MODELS'),\n    temperature=0.2,\n)\n\nllm_with_tools = llm.bind_tools(TOOLS)\n\ncustom_prompt = ChatPromptTemplate.from_messages(\n    [\n        (\n            \"system\",\n            f\"\"\"\n            Vous êtes un assistant spécialisé pour aider les usagers de l'Île-de-France à trouver leur itinéraire dans les transports en commun.\n\n            Consignes :\n            Utilisez un langage simple et naturel, car le texte sera lu à voix haute.\n            Nous sommes le {datetime.now().strftime(\"%Y-%m-%d\")}.\n            Il est {datetime.now().strftime(\"%H:%M:%S\")}.\n            Si l'utilisateur n'en fournit pas, considère que c'est la date et heure de départ.\n            Si le point de départ n’est pas précisé :\n            Utilisez la géolocalisation de l’usager si elle est disponible.\n            Sinon, invitez-le à l’activer ou à préciser son départ. Ne faites pas d’hypothèses.\n            Mais utilisez le point de départ s'il est précisé.\n\n            Si la requête semble incomplete demandez plus de précisions.\n\n            Répondez en 4 lignes maximum.\n            Fournissez la réponse en indiquant l'origine et la destination, la date de départ et la date d'arrivée et les étapes principales, comme suit :\n            Exemple :\n            En partant 56 Rue de Bagnolet au 34 avenue de l'Opéra aujourd'hui à 14h, vous arriverez à 14h38. Marchez 6 minutes jusqu'à la station Alexandre Dumas, puis prenez la ligne 2 pendant 3 minutes direction Porte Dauphine jusqu'à Père Lachaise. Changez pour la ligne 3 direction Pont de Levallois pendant 11 minutes et descendez à Opéra.\n            \"\"\",\n        ),\n        (\"system\", \"User location: {user_location}\"),\n        MessagesPlaceholder(variable_name=MEMORY_KEY),\n        (\"user\", \"{input}\"),\n        MessagesPlaceholder(variable_name=\"agent_scratchpad\"),\n    ]\n)\n\nagent = (\n    {\n        \"input\": lambda x: x[\"input\"],\n        \"user_location\": lambda x: x[\"user_location\"],\n        \"agent_scratchpad\": lambda x: format_to_openai_tool_messages(\n            x[\"intermediate_steps\"]\n        ),\n        \"chat_history\": lambda x: x[\"chat_history\"],\n    }\n    | custom_prompt\n    | llm_with_tools\n    | OpenAIToolsAgentOutputParser()\n)\n\n\nagent_executor = AgentExecutor(agent=agent, tools=TOOLS, verbose=True)\n\n\ndef invoke_agent(message: str, location: str) -> str:\n\n    result = agent_executor.invoke({\"input\": message, \"user_location\": location, \"chat_history\": CHAT_HISTORY})\n\n    CHAT_HISTORY.extend(\n        [\n            HumanMessage(content=message),\n            AIMessage(content=result[\"output\"]),\n        ]\n    )\n\n    return result[\"output\"]\n\n\nif __name__ == \"__main__\":\n    invoke_agent(\n        message=(\"Je veux aller de la basilique Montmartre a la gare Montparnasse\"),\n        location=None\n    )","description":"Ce code définit un agent conversationnel utilisant Azure OpenAI pour aider les usagers de l'Île-de-France à trouver des itinéraires de transport en commun. Il utilise des outils pour obtenir des itinéraires et des informations sur le trafic, et génère des réponses basées sur des prompts personnalisés.","reutilisabilite":"Le code est hautement réutilisable grâce à son abstraction et modularité. Il intègre des outils pour obtenir des itinéraires et des informations sur le trafic, ce qui peut être adapté à d'autres régions ou services de transport. L'utilisation de prompts personnalisés permet de modifier facilement le comportement de l'agent.","specificites_fonctionnelles":"Le code répond aux besoins fonctionnels du projet en fournissant des itinéraires de transport en commun personnalisés pour les usagers de l'Île-de-France, en tenant compte de la géolocalisation et des préférences de l'utilisateur.","value_index":0.0015818613234906407}
{"themes":"Utilisation de l\\'API IDFM, Création d\\'une interface utilisateur (IHM), Manipulation de données, ","id_pepite":107,"equipe":"equipe_07_tranquiliscore","langage":"JAVASCRIPT","is_api_idfm":1,"is_api_autres":0,"is_appel_llm":0,"is_creation_ihm":1,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":0,"is_geocoding":0,"is_angular":0,"is_data_generation":0,"is_data_manipulation":1,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_07_tranquiliscore/tranquili-score-main/Documents/t-app-js/script_agent.js","code":"// Fonction pour parser le CSV\nfunction parseCSV(csv, delimiter = ';') {\n    const lines = csv.split('\\n'); // Diviser le CSV en lignes\n    const headers = lines[0].split(delimiter); // Extraire l'en-tête\n\n    // Créer des objets pour chaque ligne\n    return lines.slice(1).map(line => {\n        const values = line.split(delimiter);\n        const obj = {};\n        headers.forEach((header, index) => {\n            obj[header.trim()] = values[index]?.trim();\n        });\n        return obj;\n    });\n}\n\n// Initialiser la carte\nconst map = L.map('map').setView([48.8566, 2.3522], 13);\n\n// Ajouter une couche de tuiles\nL.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {\n    attribution: '© OpenStreetMap contributors'\n}).addTo(map);\n\n// Fonction pour charger et parser le fichier CSV\nfunction loadCSV() {\n    const fileInput = document.getElementById('fileInput');\n    const file = fileInput.files[0]; // Obtenir le fichier sélectionné\n\n    if (!file) {\n        alert('Veuillez sélectionner un fichier CSV.');\n        return;\n    }\n\n    const reader = new FileReader();\n\n    // Lire le fichier en tant que texte\n    reader.onload = function(event) {\n        const csvText = event.target.result;\n        const data = parseCSV(csvText); // Parser le CSV en objets\n\n        // Effacer les anciens marqueurs (si nécessaire)\n        map.eachLayer(layer => {\n            if (layer instanceof L.Marker) {\n                map.removeLayer(layer);\n            }\n        });\n\n        console.log(data);\n        // Ajouter des marqueurs en fonction des données du CSV\n        data.forEach(row => {\n            const latitude = row['Lat_A'];\n            const longitude = row['Long_A'];\n            const securite = parseFloat(row['Indice_gare_A']);\n            const nom = row['Gare_A'];\n            console.log(latitude,longitude);\n            console.log(securite);\n            if (!isNaN(securite)) {\n                const [lat, lng] = [latitude,longitude];\n\n                // Déterminer l'icône et sa classe en fonction de l'indice de sécurité\n                if (securite >= 0 && securite < 0.2) {\n                    iconPath =  'ressources/visage_effrayé.png';\n                    iconClass = 'red-smiley';\n                } else if (securite >= 0.2 && securite < 0.4) {\n                    iconPath = 'ressources/visage_inquiet.png';\n                    iconClass = 'yellow-smiley';\n                } else if (securite >= 0.4 && securite <= 0.6) {\n                    iconPath = 'ressources/visage_neutre.png';\n                    iconClass = 'yellow-smiley';\n                }else if (securite >= 0.6 && securite <= 0.8) {\n                    iconPath = 'ressources/visage_sourire.png';\n                    iconClass = 'green-smiley';\n                }else if (securite >= 0.8 && securite <= 1) {\n                    iconPath = 'ressources/visage_rieur.png';\n                    iconClass = 'green-smiley';\n                }\n\n                // Créer une icône personnalisée\n                const customIcon = L.icon({\n                    className: iconClass,\n                    iconUrl: iconPath,\n                    iconSize: [25, 25],\n                    iconAnchor: [16, 16],\n                    popupAnchor: [0, -16],\n                });\n\n                // Ajouter un marqueur à la carte\n                L.marker([lat, lng], { icon: customIcon })\n                    .addTo(map)\n                    .bindPopup(`Gare : ${nom}<br>Indice de sécurité : ${securite}`);\n                \n            }\n        });\n    };\n\n    reader.readAsText(file); // Lire le fichier CSV comme texte\n}","description":"Ce code initialise une carte interactive avec Leaflet, charge un fichier CSV, et place des marqueurs sur la carte en fonction des données de sécurité des gares. Les marqueurs sont personnalisés avec des icônes en fonction de l'indice de sécurité.","reutilisabilite":"Le code est réutilisable pour toute application nécessitant l'affichage de données géographiques à partir d'un fichier CSV. La fonction de parsing CSV et l'intégration avec Leaflet pour l'affichage de cartes sont des composants modulaires.","specificites_fonctionnelles":"Le code répond au besoin de visualiser des données de sécurité des gares sur une carte, ce qui est pertinent pour des applications de transport ou de sécurité publique.","value_index":0.0008333333333333334}
{"themes":"Utilisation de l\\'API IDFM, Création d\\'une interface utilisateur (IHM), Manipulation de données, ","id_pepite":115,"equipe":"equipe_07_tranquiliscore","langage":"JAVASCRIPT","is_api_idfm":1,"is_api_autres":0,"is_appel_llm":0,"is_creation_ihm":1,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":0,"is_geocoding":0,"is_angular":0,"is_data_generation":0,"is_data_manipulation":1,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_07_tranquiliscore/tranquili-score-main/Documents/t-app-js/script_utilisateur.js","code":"// Fonction pour parser le CSV\nfunction parseCSV(csv, delimiter = ';') {\n    const lines = csv.split('\\n'); // Diviser le CSV en lignes\n    const headers = lines[0].split(delimiter);\n\n    return lines.slice(1).map(line => {\n        const values = line.split(delimiter);\n        const obj = {};\n        headers.forEach((header, index) => {\n            obj[header.trim()] = values[index]?.trim();\n        });\n        return obj;\n    });\n}\n\n// Initialiser la carte\nconst map = L.map('map').setView([48.8566, 2.3522], 13);\n\n// Ajouter une couche de tuiles\nL.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {\n    attribution: '© OpenStreetMap contributors'\n}).addTo(map);\n\nfunction loadCSV() {\n    const fileInput = document.getElementById('fileInput');\n    const file = fileInput.files[0]; // Obtenir le fichier sélectionné\n\n    if (!file) {\n        alert('Veuillez sélectionner un fichier CSV.');\n        return;\n    }\n\n    const reader = new FileReader();\n\n    // Lire le fichier en tant que texte\n    reader.onload = function (event) {\n        const csvText = event.target.result;\n        const data = parseCSV(csvText); // Parser le CSV en objets\n\n        // Effacer les anciennes lignes ou marqueurs (si nécessaire)\n        map.eachLayer(layer => {\n            if (layer instanceof L.Polyline || layer instanceof L.Marker) {\n                map.removeLayer(layer);\n            }\n        });\n\n        // Créer une enveloppe pour ajuster les limites de la carte\n        const bounds = L.latLngBounds();\n\n        // Fonction pour déterminer la couleur en fonction de l'indice\n        function getColor(indice) {\n            if (indice <= 0.2) return 'red';\n            if (indice <= 0.4) return 'orange';\n            if (indice <= 0.6) return 'yellow';\n            if (indice <= 0.8) return '#2ea822';\n            return '#007c01';\n        }\n\n        // Parcourir chaque ligne du fichier et tracer un trajet\n        data.forEach(row => {\n            const latA = parseFloat(row['Lat_A']);\n            const longA = parseFloat(row['Long_A']);\n            const latB = parseFloat(row['Lat_B']);\n            const longB = parseFloat(row['Long_B']);\n            const indiceTroncon = parseFloat(row['Indice_troncon_AB']); // Indice du tronçon\n\n            if (!isNaN(latA) && !isNaN(longA) && !isNaN(latB) && !isNaN(longB) && !isNaN(indiceTroncon)) {\n                // Déterminer la couleur du chemin en fonction de l'indice\n                const color = getColor(indiceTroncon);\n\n                // Ajouter les points aux limites\n                bounds.extend([latA, longA]);\n                bounds.extend([latB, longB]);\n\n                // Créer une polyligne entre les deux points\n                const polyline = L.polyline(\n                    [\n                        [latA, longA],\n                        [latB, longB],\n                    ],\n                    {\n                        color: color,\n                        weight: 10,\n                        opacity: 1,\n                        lineJoin: 'round',\n                    }\n                ).addTo(map);\n\n                // Ajouter des marqueurs pour chaque gare avec leurs infos\n                const iconA = L.divIcon({\n                    className: 'icon-a',\n                    html: `<b style=\"color: blue;\">O</b>`,\n                    iconSize: [20, 20],\n                });\n                const iconB = L.divIcon({\n                    className: 'icon-b',\n                    html: `<b style=\"color: red;\"></b>`,\n                    iconSize: [0, 0],\n                });\n\n                L.marker([latA, longA], { icon: iconA })\n                    .addTo(map)\n                    .bindPopup(`Gare A : ${row['Gare_A']}<br>Indice : ${row['Indice_gare_A']}`);\n\n                L.marker([latB, longB], { icon: iconB })\n                    .addTo(map)\n                    .bindPopup(`Gare B : ${row['Gare_B']}<br>Indice : ${row['Indice_gare_B']}`);\n            }\n        });\n\n        // Centrer la carte pour inclure toutes les lignes tracées\n        map.fitBounds(bounds);\n    };\n\n    reader.readAsText(file);\n}","description":"Ce code charge un fichier CSV, parse les données, et affiche des trajets entre deux points sur une carte Leaflet. Les trajets sont colorés en fonction d'un indice de sécurité.","reutilisabilite":"Le code est réutilisable pour des applications nécessitant l'affichage de trajets ou de routes sur une carte à partir de données CSV. La fonction de parsing CSV et l'utilisation de Leaflet pour le rendu cartographique sont des éléments modulaires.","specificites_fonctionnelles":"Le code permet de visualiser des trajets entre gares avec des indices de sécurité, ce qui est utile pour des applications de transport ou de planification de trajets sécurisés.","value_index":0.0007309941520467836}
{"themes":"Utilisation de l\\'API IDFM, Création d\\'une interface utilisateur (IHM), Traitement audio ou vocal, Utilisation de Websockets, ","id_pepite":102,"equipe":"equipe_05_mobilia","langage":"JAVASCRIPT","is_api_idfm":1,"is_api_autres":0,"is_appel_llm":0,"is_creation_ihm":1,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":1,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":1,"is_prompt_design":0,"is_geocoding":0,"is_angular":0,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_05_mobilia/MobilIA-main/app/src/hooks/realtime.ts","code":"import { useState, useEffect, useCallback } from 'react';\nimport { Player } from '../lib/player';\nimport { Recorder } from '../lib/recorder';\nimport { getCurrentLocation } from '../utils/geolocation';\nimport { Journey } from '../api/directions';\n\nconst BUFFER_SIZE = 4096;\n\nexport const useRealtime = (onNewMessage?: (message: string, isBot: boolean, journeys?: Journey[]) => void) => {\n    const [isAudioOn, setIsAudioOn] = useState(false);\n    const [audioPlayer] = useState(() => new Player());\n    const [audioRecorder, setAudioRecorder] = useState<Recorder | null>(null);\n    const [webSocket, setWebSocket] = useState<WebSocket | null>(null);\n\n    const [currentLocation, setCurrentLocation] = useState<{ latitude: number; longitude: number } | null>(null);\n\n    const startAudio = useCallback(async () => {\n        try {\n            const ws = new WebSocket(\"ws://localhost:8000/ws\");\n            setWebSocket(ws);\n\n            await audioPlayer.init(24000);\n\n            let buffer = new Uint8Array();\n\n            const appendToBuffer = (newData: Uint8Array) => {\n                const newBuffer = new Uint8Array(buffer.length + newData.length);\n                newBuffer.set(buffer);\n                newBuffer.set(newData, buffer.length);\n                buffer = newBuffer;\n            };\n\n            const handleAudioData = (data: ArrayBuffer) => {\n                const uint8Array = new Uint8Array(data);\n                appendToBuffer(uint8Array);\n\n                if (buffer.length >= BUFFER_SIZE) {\n                    const toSend = new Uint8Array(buffer.slice(0, BUFFER_SIZE));\n                    buffer = new Uint8Array(buffer.slice(BUFFER_SIZE));\n\n                    const regularArray = String.fromCharCode(...toSend);\n                    const base64 = btoa(regularArray);\n\n                    ws.send(JSON.stringify({ type: 'input_audio_buffer.append', audio: base64 }));\n                }\n            };\n\n            const recorder = new Recorder(handleAudioData);\n            setAudioRecorder(recorder);\n\n            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\n            await recorder.start(stream);\n\n            setIsAudioOn(true);\n        } catch (error) {\n            console.error('Error starting audio:', error);\n            alert('Error accessing the microphone. Please check your settings and try again.');\n        }\n    }, [audioPlayer]);\n\n    const stopAudio = useCallback(() => {\n        if (audioRecorder) {\n            audioRecorder.stop();\n        }\n        if (webSocket) {\n            webSocket.close();\n        }\n        setIsAudioOn(false);\n    }, [audioRecorder, webSocket]);\n\n    useEffect(() => {\n        if (webSocket) {\n            webSocket.onmessage = (event) => {\n                const data = JSON.parse(event.data);\n                const handleTranscription = (transcript: string, isAIResponse: boolean) => {\n                    console.log(`${isAIResponse ? 'AI' : 'User'} transcription:`, transcript);\n                    if (typeof onNewMessage === 'function') {\n                        onNewMessage?.(transcript, isAIResponse);\n                    }\n                };\n\n                if (data?.type === 'conversation.item.input_audio_transcription.completed') {\n                    handleTranscription(data.transcript, false);\n                } else if (data?.type === 'response.audio_transcript.done') {\n                    handleTranscription(data.transcript, true);\n                }\n                if (data?.type === 'response.function_call_arguments.done') {\n                    console.log('AI function_call_arguments:', data.transcript);\n                }\n                if (data?.type === 'tools.tool_outputs') {\n                    console.log('Received tool output:', data);\n                    const args = JSON.parse(data.response.item.args);\n                    const output = JSON.parse(data.response.item.output);\n                    console.log('tools.tool_outputs:', output);\n                    if (args.start && output.length > 0) {\n                        onNewMessage?.(\"Voici les résultats : \", true, output);\n                    }\n\n                }\n                if (data?.type !== 'response.audio.delta') return;\n\n                const binary = atob(data.delta);\n                const bytes = Uint8Array.from(binary, c => c.charCodeAt(0));\n                const pcmData = new Int16Array(bytes.buffer);\n\n                audioPlayer.play(pcmData);\n            };\n        }\n    }, [webSocket, audioPlayer, onNewMessage]);\n\n    return {\n        isAudioOn,\n        startAudio,\n        stopAudio\n    };\n}","description":"Ce hook React gère la capture et la transmission audio en temps réel via WebSocket. Il permet de démarrer et d'arrêter l'enregistrement audio, d'envoyer des données audio à un serveur WebSocket, et de traiter les réponses reçues, notamment les transcriptions audio.","reutilisabilite":"Le hook est hautement réutilisable pour toute application nécessitant une communication audio en temps réel. Il encapsule la logique de gestion des WebSockets et de l'audio, ce qui le rend adaptable à divers scénarios d'interaction vocale.","specificites_fonctionnelles":"Permet l'interaction vocale en temps réel, ce qui est essentiel pour des applications de navigation ou d'assistance vocale.","value_index":0.0008656135035706557}
{"themes":"Utilisation de l\\'API IDFM, Génération de données, ","id_pepite":1,"equipe":"equipe_10_ivoice","langage":"PYTHON","is_api_idfm":1,"is_api_autres":0,"is_appel_llm":0,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":0,"is_geocoding":0,"is_angular":0,"is_data_generation":1,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_10_ivoice/ivoice-main/src/disruption_generation.py","code":"def create_disruption(): ...","description":"Cette fonction génère une perturbation aléatoire à partir d'un historique de perturbations pour la ligne 9 du métro.","reutilisabilite":"La fonction peut être adaptée pour générer des perturbations pour d'autres lignes ou services, ce qui est utile pour simuler des scénarios de perturbation.","specificites_fonctionnelles":"Répond au besoin de simuler des perturbations pour tester la robustesse des systèmes de gestion de trafic.","value_index":0.07142857142857142}
{"themes":"Utilisation de l\\'API IDFM, Géocodage, ","id_pepite":86,"equipe":"equipe_05_mobilia - MobilIA","langage":"PYTHON","is_api_idfm":1,"is_api_autres":0,"is_appel_llm":0,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":0,"is_geocoding":1,"is_angular":0,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_05_mobilia/MobilIA-main%20%-%20%MobilIA/server/src/server/directions.py","code":"class DirectionsAPI:\n    def __init__(self, api_key):\n        self.api_key = api_key\n        self.geocoding_api = GeocodingAPI()\n\n    async def get_journey_info(self, origin_long, origin_lat, dest_long, dest_lat, datetime_str, wheelchair=False):\n        base_url = 'https://prim.iledefrance-mobilites.fr/marketplace/v2/navitia/journeys'\n        params = {\n            'from': f\"{origin_long};{origin_lat}\",\n            'to': f\"{dest_long};{dest_lat}\",\n            'datetime': datetime_str,\n            'data_freshness': 'realtime'\n        }\n        if wheelchair:\n            params['wheelchair'] = 'true'\n            params['max_duration_to_pt'] = 300\n\n        headers = {\n            'Accept': 'application/json',\n            'apikey': self.api_key\n        }\n\n        try:\n            response = requests.get(base_url, headers=headers, params=params)\n            response.raise_for_status()\n            journey_data = response.json()\n            return journey_data\n        except requests.exceptions.RequestException as e:\n            print(f\"API request error: {e}\")\n            return None","description":"Cette classe et méthode permettent de récupérer des informations de trajet en utilisant l'API de transport de PRIM. Elle gère les paramètres de localisation, de date et d'accessibilité pour les utilisateurs en fauteuil roulant.","reutilisabilite":"Le code est modulaire et peut être réutilisé pour intégrer des fonctionnalités de recherche de trajets dans d'autres applications de mobilité. Il utilise des appels d'API standardisés et gère les exceptions.","specificites_fonctionnelles":"Répond aux besoins de mobilité en temps réel et inclut des options pour les utilisateurs en fauteuil roulant.","value_index":0.0018281535648994515}
{"themes":"Utilisation de l\\'API IDFM, Prise en compte de la frugalité, ","id_pepite":89,"equipe":"equipe_05_mobilia","langage":"JAVASCRIPT","is_api_idfm":1,"is_api_autres":0,"is_appel_llm":0,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":0,"is_geocoding":0,"is_angular":0,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_05_mobilia/MobilIA-main/app/src/api/directions.ts","code":"import axios from 'axios';\n\nexport interface Disruption {\n  effect: string;\n  id: string;\n  messages: string[];\n  severity: string;\n  status: string;\n}\n\nexport interface Section {\n  arrival_time: string;\n  departure_time: string;\n  from: string | null;\n  mode: string | null;\n  to: string | null;\n  type: string;\n  disruptions: Disruption[];\n}\n\nexport interface Journey {\n  arrival_date_time: string;\n  co2_emission: number;\n  departure_date_time: string;\n  duration: number;\n  nb_transfers: number;\n  sections: Section[];\n  status: string;\n  type: string;\n  walking_distance: number;\n}\n\nexport async function getDirections(\n  originLong: number,\n  originLat: number,\n  destLong: number,\n  destLat: number,\n  dateTime: string,\n  wheelchair: boolean = false\n): Promise<Journey[]> {\n  try {\n    const response = await axios.get('http://localhost:8000/api/directions', {\n      params: {\n        origin_long: originLong,\n        origin_lat: originLat,\n        dest_long: destLong,\n        dest_lat: destLat,\n        datetime: dateTime,\n        wheelchair: wheelchair\n      }\n    });\n\n    return response.data;\n  } catch (error) {\n    console.error('Error fetching directions:', error);\n    throw error;\n  }\n}","description":"Ce code définit des interfaces pour les perturbations, les sections et les trajets, et implémente une fonction asynchrone pour obtenir des directions en utilisant une API locale. La fonction prend en compte les coordonnées d'origine et de destination, la date et l'heure, et une option pour les utilisateurs en fauteuil roulant.","reutilisabilite":"La fonction `getDirections` est hautement réutilisable pour toute application nécessitant des calculs d'itinéraires, en particulier dans le contexte de la mobilité. Les interfaces définies permettent une structuration claire des données de trajet.","specificites_fonctionnelles":"Répond aux besoins de calcul d'itinéraires en tenant compte des perturbations et des options d'accessibilité pour les personnes en fauteuil roulant.","value_index":0.0016611295681063123}
{"themes":"Utilisation de l\\'API IDFM, Utilisation d\\'autres API, ","id_pepite":2,"equipe":"equipe_06_mob_ia","langage":"PYTHON","is_api_idfm":1,"is_api_autres":1,"is_appel_llm":0,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":0,"is_geocoding":0,"is_angular":0,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_06_mob_ia/hackathon_idfm_octo_2024-main/sources/api/api_prim.py","code":"def get_place(adresse: str) -> str: ...","description":"Cette fonction utilise l'API PRIM pour obtenir l'identifiant d'un lieu à partir d'une adresse donnée.","reutilisabilite":"La fonction encapsule l'appel à l'API PRIM pour la recherche de lieux, ce qui la rend réutilisable pour toute application nécessitant une géolocalisation basée sur une adresse.","specificites_fonctionnelles":"Permet de convertir une adresse en un identifiant de lieu utilisable pour d'autres appels API.","value_index":0.05128205128205128}
{"themes":"Utilisation de l\\'API IDFM, Utilisation de LangChain, ","id_pepite":64,"equipe":"equipe_06_mob_ia","langage":"PYTHON","is_api_idfm":1,"is_api_autres":0,"is_appel_llm":0,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":1,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":0,"is_geocoding":0,"is_angular":0,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_06_mob_ia/hackathon_idfm_octo_2024-main/sources/agent/tools/get_info_trafic.py","code":"from typing import Annotated\n\nfrom sources.api.api_prim import call_info_trafic\n\nfrom langchain_core.tools import tool\n\n\n@tool\ndef get_info_trafic(\n    ligne: Annotated[\n        str, \"Ligne de transport sur laquelle nous cherchons des informations sans le type (métro/rer/...)\"\n             \"Exemple RER E -> E\"]\n) -> str:\n    \"\"\"\n        Récupère les informations sur les potentiels problèmes des moyens de transport.\n    \"\"\"\n    try:\n        return call_info_trafic(ligne)\n    except Exception as err:\n        return f\"Une erreur est survenue lors de la recherche d'info trafic: {err}\"","description":"Cette fonction récupère les informations de trafic pour une ligne de transport donnée, en utilisant l'API PRIM.","reutilisabilite":"La fonction est réutilisable pour toute application nécessitant des informations de trafic en temps réel pour les lignes de transport en Île-de-France.","specificites_fonctionnelles":"Répond au besoin de fournir des informations de trafic en temps réel pour les utilisateurs des transports en commun.","value_index":0.0034071550255536627}
{"themes":"Utilisation de l\\'API IDFM, Utilisation de Retrieval-Augmented Generation (RAG), Utilisation de Websockets, ","id_pepite":108,"equipe":"equipe_04_mobiwize","langage":"JAVASCRIPT","is_api_idfm":1,"is_api_autres":0,"is_appel_llm":0,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":1,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":0,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":1,"is_prompt_design":0,"is_geocoding":0,"is_angular":0,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_04_mobiwize/index.ts","code":"import express from 'express';\nimport WebSocket from \"ws\";\nimport {graphRag} from \"@repo/ai-toolkit/graphs/rag\";\n\n// Message type definitions\ninterface BaseMessage {\n  type: string;\n  payload: any;\n}\n\ninterface UserMessage extends BaseMessage {\n  type: 'USER_MESSAGE';\n  payload: {\n    content: string;\n  };\n}\n\ninterface ToolUpdate extends BaseMessage {\n  type: 'TOOL_UPDATE';\n  payload: {\n    toolName: string;\n    data: any;\n  };\n}\n\ninterface SystemMessage extends BaseMessage {\n  type: 'SYSTEM_MESSAGE';\n  payload: {\n    status: string;\n    message: string;\n  };\n}\n\ntype WebSocketMessage = UserMessage | ToolUpdate | SystemMessage;\n\nconst app = express();\n\n// Create WebSocket server\nconst wss = new WebSocket.Server({port: 9998});\n\n// Broadcast to all connected clients\nconst broadcast = (message: any) => {\n  wss.clients.forEach((client) => {\n    if (client.readyState === WebSocket.OPEN) {\n      client.send(JSON.stringify(message));\n    }\n  });\n};\n\nconst processRagStream = async (content: string) => {\n  try {\n    for await (const chunk of await graphRag.stream({\n      messages: [{role: \"user\", content}]\n    }, {\n      configurable: {\n        thread_id: \"1\"\n      },\n      streamMode: \"updates\",\n    })) {\n      for (const [node, values] of Object.entries(chunk)) {\n        console.log(`Receiving update from node: ${node}`);\n\n        // Broadcast node updates\n        broadcast({\n          type: 'NODE_UPDATE',\n          payload: {\n            node,\n            values\n          }\n        });\n      }\n    }\n  } catch (error) {\n    console.error('Error processing RAG stream:', error);\n    broadcast({\n      type: 'SYSTEM_MESSAGE',\n      payload: {\n        status: 'error',\n        message: 'Error processing request'\n      }\n    });\n  }\n};\n\n// Message handlers\nconst messageHandlers = {\n  USER_MESSAGE: async (payload: UserMessage['payload'], ws: WebSocket) => {\n    console.log('Processing user message:', payload.content);\n    await processRagStream(payload.content);\n  },\n\n  TOOL_UPDATE: (payload: ToolUpdate['payload'], ws: WebSocket) => {\n    console.log(`Tool update received from ${payload.toolName}:`, payload.data);\n  },\n\n  SYSTEM_MESSAGE: (payload: SystemMessage['payload'], ws: WebSocket) => {\n    console.log('System message:', payload.message);\n    broadcast({\n      type: 'SYSTEM_MESSAGE',\n      payload\n    });\n  }\n};\n\n// WebSocket connection handler\nwss.on('connection', (ws: WebSocket) => {\n  console.log('New client connected');\n\n  // Message handler\n  ws.on('message', async (message: string) => {\n    try {\n      const parsedMessage = JSON.parse(message) as WebSocketMessage;\n\n      if (messageHandlers[parsedMessage.type]) {\n        await messageHandlers[parsedMessage.type](parsedMessage.payload as any, ws);\n      } else {\n        ws.send(JSON.stringify({\n          type: 'SYSTEM_MESSAGE',\n          payload: {\n            status: 'error',\n            message: `Unsupported message type: ${parsedMessage.type}`\n          }\n        }));\n      }\n    } catch (error) {\n      console.error('Error processing message:', error);\n      ws.send(JSON.stringify({\n        type: 'SYSTEM_MESSAGE',\n        payload: {\n          status: 'error',\n          message: 'Error processing message'\n        }\n      }));\n    }\n  });\n\n  // Error handler\n  ws.on('error', (error) => {\n    console.error('WebSocket error:', error);\n  });\n\n  // Disconnection handler\n  ws.on('close', () => {\n    console.log('Client disconnected');\n  });\n});\n\n// Express routes\napp.get('/', (req, res) => {\n  res.send('Hello World!');\n});\n\n// Start server\napp.listen(9999, () => {\n  console.info(`Express server listening on port 9999`);\n  console.info(`WebSocket server listening on port 9998`);\n});","description":"Ce code met en place un serveur Express et un serveur WebSocket pour gérer les communications en temps réel. Il définit plusieurs types de messages WebSocket et des gestionnaires pour traiter les messages utilisateur, les mises à jour d'outils et les messages système. Le serveur utilise la bibliothèque 'graphRag' pour traiter les flux de données en temps réel et diffuser les mises à jour aux clients connectés.","reutilisabilite":"Le code est hautement réutilisable grâce à sa modularité et à son abstraction des types de messages. Il intègre un serveur WebSocket pour la communication en temps réel, ce qui est précieux pour les applications nécessitant des mises à jour instantanées. L'utilisation de 'graphRag' pour le traitement des flux de données en fait un composant clé pour les applications de traitement de données en temps réel.","specificites_fonctionnelles":"Le code répond aux besoins de communication en temps réel et de traitement de données en continu, ce qui est essentiel pour les applications nécessitant des mises à jour instantanées et une gestion efficace des flux de données.","value_index":0.000812787862367922}
{"themes":"Validation des données, ","id_pepite":12,"equipe":"equipe_05_mobilia - MobilIA","langage":"PYTHON","is_api_idfm":0,"is_api_autres":0,"is_appel_llm":0,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":1,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":0,"is_geocoding":0,"is_angular":0,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_05_mobilia/MobilIA-main%20%-%20%MobilIA/server/src/server/app.py","code":"async def get_directions(request: Request): ...","description":"Cette fonction gère une requête HTTP pour obtenir des directions. Elle extrait les paramètres de la requête, valide leur présence, et utilise une API externe pour récupérer et parser les informations de trajet.","reutilisabilite":"La fonction 'get_directions' est réutilisable pour toute application nécessitant des services de direction, grâce à son abstraction des détails de validation des paramètres et de l'appel à l'API de directions.","specificites_fonctionnelles":"Répond aux besoins de calcul de trajets en intégrant une API de directions, avec une gestion des erreurs et des validations robustes.","value_index":0.02127659574468085}
{"themes":"Validation des données, ","id_pepite":13,"equipe":"equipe_05_mobilia","langage":"PYTHON","is_api_idfm":0,"is_api_autres":0,"is_appel_llm":0,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":1,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":0,"is_geocoding":0,"is_angular":0,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_05_mobilia/MobilIA-main/server/src/server/tools.py","code":"@tool\nasync def check_address(address: str):\n    ...","description":"Fonction asynchrone pour vérifier ou désambiguïser une adresse en utilisant une API de géocodage.","reutilisabilite":"Cette fonction est précieuse pour toute application nécessitant une vérification ou une désambiguïsation d'adresses, en encapsulant l'appel à une API de géocodage.","specificites_fonctionnelles":"Répond au besoin de validation et de désambiguïsation d'adresses dans le cadre de la gestion de trajets.","value_index":0.019230769230769232}
{"themes":"Validation des données, ","id_pepite":32,"equipe":"equipe_01_accit_falc","langage":"PYTHON","is_api_idfm":0,"is_api_autres":0,"is_appel_llm":0,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":1,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":0,"is_geocoding":0,"is_angular":0,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_01_accit_falc/accit-api-main/app/models/score_falceur.py","code":"from pydantic import BaseModel\n\n\nclass FalcScore(BaseModel):\n    good: list[str]\n    bad: list[str]\n    improve: list[str]\n    score: float","description":"Ce code définit un modèle de données nommé FalcScore utilisant Pydantic, qui est une bibliothèque de validation de données. Le modèle contient des listes de chaînes de caractères pour les catégories 'good', 'bad', et 'improve', ainsi qu'un score de type float.","reutilisabilite":"Le modèle FalcScore est réutilisable pour structurer et valider des données de score dans d'autres parties de l'application ou dans d'autres projets nécessitant une évaluation qualitative et quantitative.","specificites_fonctionnelles":"Le modèle répond à un besoin fonctionnel de structuration et de validation des données de score, ce qui est essentiel pour garantir l'intégrité des données dans l'application.","value_index":0.007194244604316547}
{"themes":"Validation des données, ","id_pepite":85,"equipe":"equipe_07_tranquiliscore","langage":"PYTHON","is_api_idfm":0,"is_api_autres":0,"is_appel_llm":0,"is_creation_ihm":0,"is_creation_api":0,"is_appel_whisper":0,"is_referentiel_evenements":0,"is_datalake":0,"is_rag":0,"is_audio_vocal":0,"is_image":0,"is_donnees_validations":1,"is_ml":0,"is_langchain":0,"is_carto":0,"is_nlp":0,"is_websocket":0,"is_prompt_design":0,"is_geocoding":0,"is_angular":0,"is_data_generation":0,"is_data_manipulation":0,"lien_clean_encoded":"https://github.com/IleDeFranceMobilites/hackathon_ia_mobilites_2024/tree/main/resultats/repositories/equipe_07_tranquiliscore/tranquili-score-main/pre-processing-creation","code":"data_val_final = data_val.drop(['ventilation_ligne','validations_entree','validations_sortie','PA','type_jour','Key'],axis=1).rename(columns={'date':'Date','CodeGare':'Gare_A'})\ndata_val_final['Date'] = data_val_final['Date'].apply(lambda x: str(x)[:10])\ndata_val_final['Datetime'] = data_val_final['Date'] + ' ' + data_val_final['tranche_horaire'].replace({24:0,25:1,26:2}).astype(str) +':'+ data_val_final['demi_heure'].apply(lambda x: '00' if x=='0-30' else '30')+\":00\"\n\ndata_val_final['Datetime'] = pd.to_datetime(data_val_final['Datetime'])","description":"Ce code prépare les données de validation en nettoyant et en transformant les colonnes pour créer un champ 'Datetime' utilisable.","reutilisabilite":"La transformation des données temporelles en un format standardisé est une pratique courante et réutilisable dans le prétraitement des données.","specificites_fonctionnelles":"Prépare les données de validation pour une analyse temporelle en créant un champ datetime standardisé.","value_index":0.001834862385321101}
